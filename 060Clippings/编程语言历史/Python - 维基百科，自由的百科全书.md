---
title: "Python - 维基百科，自由的百科全书"
date: "2025-02-25T16:45:04+08:00"
author:
  - "[[维基媒体项目贡献者]]"
tags:
  - "clippings"
category: "编程语言"
rating: "7"
published: 2003-08-18
description: "Python的历史"
source: "https://zh.wikipedia.org/wiki/Python"
---
<table><caption>Python</caption><tbody><tr><td colspan="2"><span><a href="https://zh.wikipedia.org/wiki/File:Python-logo-notext.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/160px-Python-logo-notext.svg.png" width="160" height="175"></a></span></td></tr><tr><th scope="row"><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">编程范型</a></th><td><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">多范型</a>：<a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">过程式</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B">结构化</a>、<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B">模块化</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84%E5%BC%8F%E7%BC%96%E7%A8%8B">反射式</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>、<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式</a></td></tr><tr><th scope="row">设计者</th><td><a href="https://zh.wikipedia.org/wiki/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86">吉多·范罗苏姆</a></td></tr><tr><th scope="row">实现者</th><td><a href="https://zh.wikipedia.org/wiki/Python%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A">Python软件基金会</a></td></tr><tr><th scope="row">发行时间</th><td>1991年<span>，​34年前</span><span>​（<span>1991</span>）</span><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-release-1"><span>[</span>1<span>]</span></a></sup></td></tr><tr><th scope="row">当前版本</th><td><div><ul><li>3.13.2<span>（2025年2月4日；稳定版本）</span><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-wikidata-b30fa7ab89fad1a0626747bd80b3d3350e7f3030-v3-2"><span>[</span>2<span>]</span></a></sup></li><li>3.14.0a5<span>（2025年2月11日；预览版本）</span><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-wikidata-4ab371936a4164ef0fb368224406a306296afe3d-v3-3"><span>[</span>3<span>]</span></a></sup><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-wikidata-3a09e4fae0f28289a9642e468319d33991cce1a2-v3-4"><span>[</span>4<span>]</span></a></sup></li></ul></div><span><a href="https://www.wikidata.org/wiki/Q28865#P348"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png" width="10" height="10"></a></span></td></tr><tr><th scope="row"><a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1">类型系统</a></th><td><a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-duck-5"><span>[</span>5<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">动态</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BC%B7%E9%A1%9E%E5%9E%8B">强类型</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-6"><span>[</span>6<span>]</span></a></sup>、<span><span><a href="https://zh.wikipedia.org/w/index.php?title=%E6%B8%90%E8%BF%9B%E7%B1%BB%E5%9E%8B&amp;action=edit&amp;redlink=1">渐进</a></span></span>（自从3.5）<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-pep483-7"><span>[</span>7<span>]</span></a></sup></td></tr><tr><th scope="row"><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></th><td><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E8%87%BA">跨平台</a></td></tr><tr><th scope="row"><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81">许可证</a></th><td><a href="https://zh.wikipedia.org/wiki/Python%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A%E8%AE%B8%E5%8F%AF%E8%AF%81">Python软件基金会许可证</a></td></tr><tr><th scope="row"><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D">文件扩展名</a></th><td>.py、.pyi、.pyc、.pyd、.pyo（3.5之前）<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-8"><span>[</span>8<span>]</span></a></sup>、.pyw、.pyz（自从3.5）<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-9"><span>[</span>9<span>]</span></a></sup></td></tr><tr><th scope="row">网站</th><td><span><a href="https://www.python.org/">www<wbr>.python<wbr>.org</a></span> <span><a href="https://www.wikidata.org/wiki/Q28865#P856"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png" width="10" height="10"></a></span></td></tr><tr><th colspan="2">主要实现产品</th></tr><tr><td colspan="2"><a href="https://zh.wikipedia.org/wiki/CPython">CPython</a>、<a href="https://zh.wikipedia.org/wiki/PyPy">PyPy</a>、<a href="https://zh.wikipedia.org/wiki/Stackless_Python">Stackless Python</a>、<a href="https://zh.wikipedia.org/wiki/MicroPython">MicroPython</a>、<span><span><a href="https://zh.wikipedia.org/w/index.php?title=CircuitPython&amp;action=edit&amp;redlink=1">CircuitPython</a></span></span>、<a href="https://zh.wikipedia.org/wiki/IronPython">IronPython</a>、<a href="https://zh.wikipedia.org/wiki/Jython">Jython</a></td></tr><tr><th colspan="2">派生副语言</th></tr><tr><td colspan="2"><a href="https://zh.wikipedia.org/wiki/Cython">Cython</a>、<a href="https://zh.wikipedia.org/wiki/PyPy#RPython">RPython</a></td></tr><tr><th colspan="2">启发语言</th></tr><tr><td colspan="2"><a href="https://zh.wikipedia.org/wiki/ABC_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)">ABC</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-faq-created-10"><span>[</span>10<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/ALGOL_68">ALGOL 68</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-98-interview-11"><span>[</span>11<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/APL%E8%AF%AD%E8%A8%80">APL</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-func-12"><span>[</span>12<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-AutoNT-1-13"><span>[</span>13<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-classmix-14"><span>[</span>14<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/CLU">CLU</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-15"><span>[</span>15<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Dylan%E8%AF%AD%E8%A8%80">Dylan</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-mro-16"><span>[</span>16<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Haskell">Haskell</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-AutoNT-3-17"><span>[</span>17<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Icon%E8%AA%9E%E8%A8%80">Icon</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-CWI_Report-18"><span>[</span>18<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Java">Java</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-AutoNT-5-19"><span>[</span>19<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Lisp">Lisp</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-AutoNT-6-20"><span>[</span>20<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Modula-3">Modula-3</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-classmix-14"><span>[</span>14<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Perl">Perl</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-21"><span>[</span>21<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Standard_ML">Standard ML</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-func-12"><span>[</span>12<span>]</span></a></sup></td></tr><tr><th colspan="2">影响语言</th></tr><tr><td colspan="2"><a href="https://zh.wikipedia.org/wiki/Boo">Boo</a>、<span><span><a href="https://zh.wikipedia.org/w/index.php?title=Cobra&amp;action=edit&amp;redlink=1">Cobra</a></span></span>、<a href="https://zh.wikipedia.org/wiki/CoffeeScript">CoffeeScript</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-22"><span>[</span>22<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/D%E8%AF%AD%E8%A8%80">D</a>、<a href="https://zh.wikipedia.org/wiki/F%E2%99%AF">F#</a>、<a href="https://zh.wikipedia.org/wiki/Godot#GDScript">GDScript</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-gdscript-23"><span>[</span>23<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Genie%E8%AA%9E%E8%A8%80">Genie</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-24"><span>[</span>24<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Go">Go</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-go-25"><span>[</span>25<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Groovy">Groovy</a>、<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-26"><span>[</span>26<span>]</span></a></sup><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-27"><span>[</span>27<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Julia%E8%AF%AD%E8%A8%80">Julia</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-Julia-28"><span>[</span>28<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Mojo">Mojo</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-Mojo-29"><span>[</span>29<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Nim">Nim</a>、<a href="https://zh.wikipedia.org/wiki/Ruby">Ruby</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-bini-30"><span>[</span>30<span>]</span></a></sup>、<span><span><a href="https://zh.wikipedia.org/w/index.php?title=Bazel_(%E8%BD%AF%E4%BB%B6)&amp;action=edit&amp;redlink=1">Starlark</a></span></span><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-starlark-31"><span>[</span>31<span>]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/Swift%E8%AA%9E%E8%A8%80">Swift</a><sup><a href="https://zh.wikipedia.org/wiki/#cite_note-lattner2014-32"><span>[</span>32<span>]</span></a></sup></td></tr><tr><td colspan="2"><ul><li><span><span><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/16px-Wikibooks-logo-en-noslogan.svg.png" width="16" height="16"></span></span> <a href="https://zh.wikipedia.org/wiki/%E7%B6%AD%E5%9F%BA%E6%95%99%E7%A7%91%E6%9B%B8">维基教科书</a>中有关<a href="https://en.wikibooks.org/wiki/zh:Python">zh:Python</a>的文本</li></ul></td></tr></tbody></table>

**Python**（英式发音：[/ˈpaɪθən/](https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99 "Help:英语国际音标")；美式发音：[/ˈpaɪθɑːn/](https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99 "Help:英语国际音标")），是一种广泛使用的[解释型](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80 "解释型语言")、[高级](https://zh.wikipedia.org/wiki/%E9%AB%98%E7%B4%9A%E8%AA%9E%E8%A8%80 "高级语言")和[通用](https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80 "通用编程语言")的[编程语言](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80 "编程语言")。Python支持多种编程范型，包括结构化、过程式、反射式、面向对象和函数式编程。它拥有[动态类型系统](https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1 "类型系统")和[垃圾回收](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_\(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8\) "垃圾回收 (计算机科学)")功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。它的语言结构以及[面向对象](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1 "面向对象程序设计")的方法，旨在帮助程序员为小型的和大型的项目编写逻辑清晰的代码。

[吉多·范罗苏姆](https://zh.wikipedia.org/wiki/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86 "吉多·范罗苏姆")于1980年代后期开始研发Python，作为[ABC语言](https://zh.wikipedia.org/wiki/ABC_\(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80\) "ABC (编程语言)")的后继者[^cwi_report-18]，它也可以被视为采用了叫做[M-表达式](https://zh.wikipedia.org/w/index.php?title=M-%E8%A1%A8%E8%BE%BE%E5%BC%8F&action=edit&redlink=1 "M-表达式（页面不存在）")的[中缀表示法](https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95 "中缀表示法")的一种[LISP](https://zh.wikipedia.org/wiki/LISP "LISP")方言[^33]。[吉多·范罗苏姆](https://zh.wikipedia.org/wiki/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86 "吉多·范罗苏姆")于1991年首次发布 Python 0.9.0[^34]。Python 2.0于2000 年发布并引入了新功能。Python 3.0于2008年发布，它是该语言的主要修订版，并非完全[向后兼容](https://zh.wikipedia.org/wiki/%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9 "向下兼容")。Python 2于2020年随2.7.18版停止支持[^35]。

Python的设计哲学，强调代码的[可读性](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E5%8F%AF%E8%AE%80%E6%80%A7 "编程可读性")和简洁的语法，尤其是使用[空格缩进](https://zh.wikipedia.org/wiki/%E8%B6%8A%E4%BD%8D%E8%A7%84%E5%88%99 "越位规则")来划分代码块。相比于[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言或[Java](https://zh.wikipedia.org/wiki/Java "Java")，Python让开发者能够用更少的代码表达想法。

Python[解释器](https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8 "解释器")本身几乎可以在所有的[操作系统](https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F "操作系统")中运行，它的官方[解释器](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8 "解释器")[CPython](https://zh.wikipedia.org/wiki/CPython "CPython")是用[C语言](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")编写的。Python是一个由社群驱动的自由[软件](https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94 "软件")，目前由[Python软件基金会](https://zh.wikipedia.org/wiki/Python%E8%BB%9F%E9%AB%94%E5%9F%BA%E9%87%91%E6%9C%83 "Python软件基金会")管理。Python是最受欢迎的编程语言之一[^36][^37][^38][^39]。

[![Python创始人吉多·范罗苏姆在2024年PyCon的照片](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Guido_van_Rossum_in_PyConUS24.jpg/360px-Guido_van_Rossum_in_PyConUS24.jpg)](https://zh.wikipedia.org/wiki/File:Guido_van_Rossum_in_PyConUS24.jpg)

Python的创始人[吉多·范罗苏姆](https://zh.wikipedia.org/wiki/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86 "吉多·范罗苏姆")，在1982年至1995年间，参与了[荷兰数学和计算机科学研究学会](https://zh.wikipedia.org/wiki/%E8%8D%B7%E5%85%B0%E6%95%B0%E5%AD%A6%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%BC%9A "荷兰数学和计算机科学研究学会")多个项目的工作[^40]。1989年的圣诞节期间，他决心开发一个新的脚本解释编程，作为[ABC语言](https://zh.wikipedia.org/wiki/ABC%E8%AA%9E%E8%A8%80 "ABC语言")的继承者，并且用它替代[Unix shell](https://zh.wikipedia.org/wiki/Unix_shell "Unix shell")和[C语言](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")来进行系统管理[^cwi_report-18]，担负与[Amoeba操作系统](https://zh.wikipedia.org/w/index.php?title=Amoeba_\(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\)&action=edit&redlink=1 "Amoeba (操作系统)（页面不存在）")[^41]之间的交互操作并进行[例外处理](https://zh.wikipedia.org/wiki/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86 "异常处理")[^faq-created-10]。他是[BBC](https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E5%BB%A3%E6%92%AD%E5%85%AC%E5%8F%B8 "英国广播公司")电视剧《[Monty Python](https://zh.wikipedia.org/wiki/%E8%92%99%E6%8F%90%C2%B7%E6%B4%BE%E6%A3%AE "蒙提·派森")[的飞行马戏团](https://zh.wikipedia.org/wiki/%E8%92%99%E6%8F%90%C2%B7%E6%B4%BE%E6%A3%AE%E7%9A%84%E9%A3%9B%E8%A1%8C%E9%A6%AC%E6%88%B2%E5%9C%98 "蒙提·派森的飞行马戏团")》的爱好者，所以选取了Python作为这个编程语言的名字[^tutorial-chapter1-42]。范罗苏姆作为Python的主要开发者，独自担负这个项目的发展决策者职责，直到2018年7月12日，他宣布从[终身仁慈独裁者](https://zh.wikipedia.org/wiki/%E7%BB%88%E8%BA%AB%E4%BB%81%E6%85%88%E7%8B%AC%E8%A3%81%E8%80%85 "终身仁慈独裁者")（BDFL）的职位上“永久休假”[^43][^44]。他在2019年1月至11月参与了第一届五人掌控委员会继续领导项目发展[^45][^46]。

在1991年2月，范罗苏姆在alt.sources上发布了最初代码（标记为版本0.9.0）[^release-1]，这时就已经存在了[带继承的](https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "继承 (计算机科学)")[类](https://zh.wikipedia.org/wiki/%E7%B1%BB_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "类 (计算机科学)")、[例外处理](https://zh.wikipedia.org/wiki/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86 "异常处理")、[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "函数 (计算机科学)")和核心[类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")`list`、`dict`、`str`等。在这个最初发行中就有了从[Modula-3](https://zh.wikipedia.org/wiki/Modula-3 "Modula-3")引进的[模块系统](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B "模块化编程")[^venners-interview-pt-1-47]，和[例外处理](https://zh.wikipedia.org/wiki/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86 "异常处理")机制[^faq-created-10]。在1994年1月，Python达到了版本1.0[^48]，其主要新特征是由Amrit Prem提供的函数式编程工具`[lambda](https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0#Python "匿名函数")`、`[map](https://zh.wikipedia.org/wiki/Map_\(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\) "Map (高阶函数)")`、`[filter](https://zh.wikipedia.org/wiki/Filter_\(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\) "Filter (高阶函数)")`和`[reduce](https://zh.wikipedia.org/wiki/Fold_\(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\) "Fold (高阶函数)")`[^49]。受[Modula-3](https://zh.wikipedia.org/wiki/Modula-3 "Modula-3")启发，Python 1.1介入了[缺省参数值](https://zh.wikipedia.org/wiki/%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0 "缺省参数")，Python 1.3介入了[关键字参数](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0 "命名参数")。Python 1.4介入了对[复数](https://zh.wikipedia.org/wiki/%E8%A4%87%E6%95%B8_\(%E6%95%B8%E5%AD%B8\) "复数 (数学)")的内置支持，还包含了采取[名字修饰](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0 "名字修饰")的一种基本形式的[数据隐藏](https://zh.wikipedia.org/w/index.php?title=%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F_\(%E7%BC%96%E7%A8%8B\)&action=edit&redlink=1 "信息隐藏 (编程)（页面不存在）")[^50]。

在2000年10月，Python 2.0发布，它从[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B "函数式编程")语言[Haskell](https://zh.wikipedia.org/wiki/Haskell "Haskell")中引进了[列表推导式](https://zh.wikipedia.org/wiki/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F "列表推导式")，并且支持了[Unicode](https://zh.wikipedia.org/wiki/Unicode "Unicode")，还向[垃圾回收系统](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_\(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8\) "垃圾回收 (计算机科学)")增加了[环](https://zh.wikipedia.org/wiki/%E7%92%B0_\(%E5%9C%96%E8%AB%96\) "环 (图论)")检测算法[^newin-2.0-51]。Python 2.1支持了静态嵌套[作用域](https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F "作用域")和[闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "闭包 (计算机科学)")[^pep-0227-52]。Python 2.2进行了重大革新，将Python中用C语言写成的[类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")，和用Python语言写成的[类](https://zh.wikipedia.org/wiki/%E7%B1%BB_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "类 (计算机科学)")，统一成在同一个层级中，使得Python的对象模型成为纯粹而一致的对象模型[^unify-53]；还介入了[迭代器](https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8 "迭代器")[^54]，受[CLU](https://zh.wikipedia.org/wiki/CLU "CLU")和[Icon](https://zh.wikipedia.org/wiki/Icon%E8%AF%AD%E8%A8%80 "Icon语言")启发的[生成器](https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\) "生成器 (计算机编程)")[^pep-0255-55]，和描述器[协议](https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE_\(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\) "协议 (面向对象编程)")[^descriptor-56]。Python 2.3介入了从[Dylan](https://zh.wikipedia.org/wiki/Dylan%E8%AF%AD%E8%A8%80 "Dylan语言")引进的[方法决定次序](https://zh.wikipedia.org/wiki/C3%E7%BA%BF%E6%80%A7%E5%8C%96 "C3线性化")[^mro-16]。Python 2.4介入了[集合](https://zh.wikipedia.org/w/index.php?title=%E9%9B%86%E5%90%88_\(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\)&action=edit&redlink=1 "集合 (抽象数据类型)（页面不存在）")类型，和函数修饰器[^decorator-57]。Python 2.5介入了`with`语句[^58]，并在官方实现中介入了[抽象语法树](https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9 "抽象语法树")[^59]。

在2008年12月，Python 3.0发布，它对语言做了较大修订而不能完全[后向兼容](https://zh.wikipedia.org/wiki/%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9 "向下兼容")[^60]，尽管提供了进行自动转换的`2to3`实用工具，仍有大量现存代码不能移植，故而Python 2.7的[产品寿命结束](https://zh.wikipedia.org/wiki/%E7%94%A2%E5%93%81%E5%A3%BD%E5%91%BD%E7%B5%90%E6%9D%9F "产品寿命结束")延期至2020年元旦。Python 3.4介入了[异步I/O](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5I/O "异步I/O")模块[^61]。Python 3.5介入了[类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")提示[^62]，和采用[async/await](https://zh.wikipedia.org/wiki/Async/await "Async/await")语法的[协程](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B "协程")[^63]。Python 3.8介入了赋值表达式[^assign-64][^65]。

在2020年10月，Python 3.9介入了内置的针对[容器](https://zh.wikipedia.org/wiki/%E5%AE%B9%E5%99%A8_\(%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\) "容器 (数据类型)")类的[泛化别名](https://zh.wikipedia.org/wiki/%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81 "参数多态")（`types.GenericAlias`）[类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")[^66]，并在官方实现中介入了新的[语法解析器](https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90 "语法分析")[^67]。Python 3.10介入了结构式[模式匹配](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D "模式匹配")[^68]，和内置的[联合类型](https://zh.wikipedia.org/wiki/%E5%92%8C%E7%B1%BB%E5%9E%8B "和类型")（`types.UnionType`）[^69]。Python 3.11对官方实现进行了优化提速[^70]。Python 3.12介入了[类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")[参数](https://zh.wikipedia.org/wiki/%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81 "参数多态")语法和`type`语句[^71]，并废弃或移除了一些过时的模块和功能。Python 3.13介入了新的[交互式解释器](https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2 "命令行界面")，并实验性的支持了在[自由线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8 "线程安全")模态下运行和[即时编译器](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")[^72]。

每个版本首次发行后，享有2年的完全支持，随后是3年的安全支持。当前只有Python 3的稳定版本3.12与3.13正在被完全支持，但仍提供对3.9、3.10和3.11版本的安全性修正[^73]。

在2024年12月，活跃的Python核心开发者，选举Pablo Galindo Salgado、Barry Warsaw、Emily Morehouse、Gregory P. Smith和Donghee Na，为2025年度“掌控委员会”的五位成员来领导这个项目[^74]。

Python是[多范型](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F "编程范式")编程语言。它完全支持[结构化编程](https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B "结构化编程")和[面向对象编程](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B "面向对象编程")，还有很多特征支持[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B "函数式编程")和[元编程](https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B "元编程")比如[元对象](https://zh.wikipedia.org/wiki/%E5%85%83%E5%AF%B9%E8%B1%A1 "元对象")[协议](https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE_\(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\) "协议 (面向对象编程)")（[元类](https://zh.wikipedia.org/wiki/%E5%85%83%E7%B1%BB "元类")和魔术方法[^special-method-names-75]）。通过扩展还可以支持很多范型，包括[面向方面编程](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%BC%96%E7%A8%8B "面向方面编程")[^76]、[契约式设计](https://zh.wikipedia.org/wiki/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1 "契约式设计")[^autont-15~16-77]和[逻辑编程](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B "逻辑编程")[^autont-17-78]。

Python使用[动态类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")，在[内存管理](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 "内存管理")上采用的[垃圾回收器](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_\(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8\) "垃圾回收 (计算机科学)")基于了[引用计数](https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0 "引用计数")[^reference_counting-79]，并且结合了检测[环](https://zh.wikipedia.org/wiki/%E7%92%B0_\(%E5%9C%96%E8%AB%96\) "环 (图论)")引用的[分代垃圾回收](https://zh.wikipedia.org/wiki/%E8%BF%BD%E8%B8%AA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6 "追踪垃圾回收")优化[^80]。它的特征还有动态[名字解析](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90_\(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\) "名字解析 (程序设计)")（[后期绑定](https://zh.wikipedia.org/w/index.php?title=%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A&action=edit&redlink=1 "后期绑定（页面不存在）")），即在程序执行期间绑定方法和变量的名字。

Python对遵循[LISP](https://zh.wikipedia.org/wiki/LISP "LISP")传统的[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B "函数式编程")提供了有限的支持[^81]，它提供了 `[map](https://zh.wikipedia.org/wiki/Map_\(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\) "Map (高阶函数)")`、`[filter](https://zh.wikipedia.org/wiki/Filter_\(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\) "Filter (高阶函数)")`和`[reduce](https://zh.wikipedia.org/wiki/Fold_\(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\) "Fold (高阶函数)")`函数[^reduce-fate-82]；[列表推导式](https://zh.wikipedia.org/wiki/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F "列表推导式")、[字典](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84 "关联数组")、[集合](https://zh.wikipedia.org/w/index.php?title=%E9%9B%86%E5%90%88_\(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\)&action=edit&redlink=1 "集合 (抽象数据类型)（页面不存在）")和[生成器表达式](https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\)#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F "生成器 (计算机编程)")。标准库中的模块`functools`和`itertools`，实现了从[Haskell](https://zh.wikipedia.org/wiki/Haskell "Haskell")和[Standard ML](https://zh.wikipedia.org/wiki/Standard_ML "Standard ML")借鉴来的函数式工具[^autont-18-83]。

Python的设计理念是“优雅”、“明确”、“简单”，它的一些重要准则被合称为“[Python之禅](https://zh.wikipedia.org/wiki/Python%E4%B9%8B%E7%A6%85 "Python之禅")”。在Python解释器内运行`import this`可以获得完整的列表，下面举出其中首要：

- 优美优于丑陋。明了优于隐晦。
- 简单优于复杂。复杂优于凌乱。
- 扁平优于嵌套。稀疏优于稠密。
- 可读性很重要。

Python开发者的方法论是“用一种方法，最好是只有一种方法来做一件事”，显著不同于以[Perl](https://zh.wikipedia.org/wiki/Perl "Perl")语言为代表的“[不止一种方法去做一件事](https://zh.wikipedia.org/wiki/%E4%B8%8D%E6%AD%A2%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8E%BB%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B "不止一种方法去做一件事")”风格。Python开发者在设计语言时，如果面临多种选择，一般会选择明确没有或者很少有歧义的语法。

范罗苏姆认为ABC语言非常优美和强大，它没有获取成功的原因是不开放造成的[^python_history-84]，故而将Python本身设计为可扩展的[^85]。Python并不把所有的特性和功能都集成到语言核心，而是提供了丰富的[API](https://zh.wikipedia.org/wiki/API "API")和工具，以便程序员能够轻松地使用Python、[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言、[Cython](https://zh.wikipedia.org/wiki/Cython "Cython")来编写扩展模块。Python还可以通过[外界函数接口](https://zh.wikipedia.org/w/index.php?title=%E5%A4%96%E7%95%8C%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3&action=edit&redlink=1 "外界函数接口（页面不存在）")如标准库中的ctypes等，来提供C语言兼容[数据类型](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_\(C%E8%AF%AD%E8%A8%80\) "数据类型 (C语言)")，并访问[动态链接库](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93 "动态链接库")或[共享库](https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%BA%93 "共享库")中的函数[^86]，从而对用其他语言编写的编程进行集成和封装。

在Python的官方实现[CPython](https://zh.wikipedia.org/wiki/CPython "CPython")中，一般避开不成熟的或者对非重要部位的加快运行速度的优化。在某些对运行速度要求很高的情况，可以使用具备[JIT](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")技术的Python实现或安装JIT扩展模块[^87]。

Python为了让代码具备高度的可阅读性，在设计时尽量使用了其它语言常用的符号和英文单字。

Python支持使用[反斜杠](https://zh.wikipedia.org/wiki/%E5%8F%8D%E6%96%9C%E6%9D%A0 "反斜杠")作为行接续符，将多个物理行合成为一个逻辑行[^explicit-line-joining-88]。在[圆括号](https://zh.wikipedia.org/wiki/%E5%9C%93%E6%8B%AC%E8%99%9F "圆括号")、[方括号](https://zh.wikipedia.org/wiki/%E6%96%B9%E6%8B%AC%E8%99%9F "方括号")或[花括号](https://zh.wikipedia.org/wiki/%E8%8A%B1%E6%8B%AC%E8%99%9F "花括号")之中的表达式，可以分裂跨越多于一个物理行而不使用反斜杠，这被称为“隐式行接续”[^explicit-line-joining-88]。[注释](https://zh.wikipedia.org/wiki/%E6%B3%A8%E9%87%8A_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80\) "注释 (计算机语言)")开始于并非[字符串文字](https://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97&action=edit&redlink=1 "字符串文字（页面不存在）")一部分的一个[井号](https://zh.wikipedia.org/wiki/%E4%BA%95%E5%8F%B7 "井号")`#`，并结束于物理行结尾；注释标示逻辑行的结束，除非已受制于隐式行接续规则；注释在语法上被忽略[^89]。

简单语句包含在一个单一的逻辑行之内，Python支持使用[分号](https://zh.wikipedia.org/wiki/%E5%88%86%E5%8F%B7 "分号")作为分隔符，将多个简单语句合并入语法意义上的一行之中[^90]。

Python语法中的复合语句，包含（成组的）其他语句；它们以某种方式影响或控制这些其他语句的执行。Python的复合语句包含一个或多个子句（clause），子句构成自一个头部（header）和一个包（suite）。特定复合语句的子句头部都在同样的[缩排](https://zh.wikipedia.org/wiki/%E7%BC%A9%E8%BF%9B%E9%A3%8E%E6%A0%BC "缩进风格")层级上，每个子句头部开始于一个唯一标识[关键字](https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99%E5%AD%97 "保留字")，并结束于一个[冒号](https://zh.wikipedia.org/wiki/%E5%86%92%E5%8F%B7 "冒号")。包是这个子句所控制的一组语句，包有两种形式，可以是与头部在同一行上的一个或多个由分号分隔的简单语句，它们跟随在这个头部的冒号之后；或者是在后续诸行上的一个或多个缩排的语句，只有这种包形式可以包含嵌套的复合语句[^91]。

Python语言遵循[越位规则](https://zh.wikipedia.org/wiki/%E8%B6%8A%E4%BD%8D%E8%A7%84%E5%88%99 "越位规则")，利用[缩进](https://zh.wikipedia.org/wiki/%E7%BC%A9%E8%BF%9B%E9%A3%8E%E6%A0%BC "缩进风格")来形成语句包，即语法意义上的[块](https://zh.wikipedia.org/wiki/%E5%9D%97_\(%E7%BC%96%E7%A8%8B\) "块 (编程)")。连续诸行的缩排层级，被用来生成[语法解析器](https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90 "语法分析")才能见到的`INDENT`和`DEDENT`记号[^92]，二者的作用相当于[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言家族的[花括号](https://zh.wikipedia.org/wiki/%E8%8A%B1%E6%8B%AC%E8%99%9F "花括号")，或[Pascal](https://zh.wikipedia.org/wiki/Pascal%E8%AA%9E%E8%A8%80 "Pascal语言")语言家族的[关键字](https://zh.wikipedia.org/wiki/%E9%97%9C%E9%8D%B5%E5%AD%97 "关键字")`begin`和`end`。增加缩进就生成`INDENT`记号，减少缩进就生成`DEDENT`记号。根据PEP 8的规定[^93]，使用4个[空格](https://zh.wikipedia.org/wiki/%E7%A9%BA%E6%A0%BC "空格")来表示每级[缩进](https://zh.wikipedia.org/wiki/%E7%BC%A9%E8%BF%9B%E9%A3%8E%E6%A0%BC "缩进风格")。[^94]

[tab](https://zh.wikipedia.org/wiki/%E5%88%B6%E8%A1%A8%E9%94%AE "制表键")字符（从左至右）被替代为1至8个空格，使得直到tab之前的诸字符加上这些替代空格的字符总数，是8的倍数（这意图同于Unix所用规则）。前导于第一个非[空白字符](https://zh.wikipedia.org/wiki/%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6 "空白字符")的空格的总数，确定了这一行的缩排层级。缩排所用诸字符，不能使用反斜杠来拆分成多个物理行；直到第一个反斜杠之前的空白确定缩排层级。如果源代码文件混合了tab和空格，并且在这种方式下缩排的意义依赖于一个tab相当于多少个空格，则这种缩排因不一致性而被报错并拒绝[^95]。

Python有如下35个[关键字](https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99%E5%AD%97 "保留字")；它们不能用作标识符[^96]：

| - `and` - `as` - `assert` - `async` - `await` | - `break` - `class` - `continue` - `def` - `del` | - `elif` - `else` - `except` - `False` - `finally` | - `for` - `from` - `global` - `if` - `import` | - `in` - `is` - `lambda` - `None` - `nonlocal` | - `not` - `or` - `pass` - `raise` - `return` | - `True` - `try` - `while` - `with` - `yield` |
| --- | --- | --- | --- | --- | --- | --- |

内置常量`True`、`False`和`None`于Python版本3.0中成为关键字，关键字`nonlocal`介入于版本3.0[^97]，关键字`async`和`await`介入于版本3.5[^98]，并在版本3.7中成为正式关键字[^99]。

在Python中，将只在特定上下文中保留的标识符，称为“软关键字”[^100]：

- `match`、`case`和[通配符](https://zh.wikipedia.org/wiki/%E9%80%9A%E9%85%8D%E7%AC%A6 "通配符")`_`，介入于版本3.10，它们在与[模式匹配](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D "模式匹配")语句有关的上下文中，可以在语法上充当关键字；但是这种区分只在语法解析器层次进行，并非在词法分析记号化层次。
- `type`，介入于版本3.12，它用在`type`语句之中。

标识符就是名字，在[ASCII](https://zh.wikipedia.org/wiki/ASCII "ASCII")范围内（U+0001..U+007F），可用于标识符的字符为：大写字母`A`至`Z`和小写字母`a`至`z`，下划线`_`以及数字`0`至`9`，但首字不可以用数字。如下[命名约定](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99_\(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\) "命名规则 (程序设计)")[^101]，是为“保留标识符类”[^102]：

- `_spam`（单下划线开头）：弱“内部使用”标识。对于`from M import *`，将不导入所有以下划线开头的对象。
- `spam_`（单下划线结尾）：为了避免与python关键字的命名冲突。
- `__spam`（双下划线开头）：在命名一个类[特性](https://zh.wikipedia.org/wiki/%E7%89%B9%E6%80%A7_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "特性 (计算机科学)")的时候，采用[名字修饰](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0 "名字修饰")，比如在类`SpamEggs`内，`__spam`将变成`_SpamEggs__spam`[^private-var-103]。
- `__spam__`（双下划线开头双下划线结尾）：指那些包含在用户控制的[命名空间](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4 "命名空间")中的“魔术”方法或[特性](https://zh.wikipedia.org/wiki/%E7%89%B9%E6%80%A7_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "特性 (计算机科学)")，比如`__delattr__`、`__dir__`、`__doc__`、`__getattribute__`、`__init__`、`__new__`、`__repr__`、`__setattr__`、`__sizeof__`等。建议永远不要将这样的命名方式应用于自己的变量或函数。

在Python文献中经常使用的[元语法变量](https://zh.wikipedia.org/w/index.php?title=%E5%85%83%E8%AF%AD%E6%B3%95%E5%8F%98%E9%87%8F&action=edit&redlink=1 "元语法变量（页面不存在）")是[spam和eggs](https://zh.wikipedia.org/w/index.php?title=%E8%82%89%E7%BD%90%E5%A4%B4_\(%E5%B7%A8%E8%9F%92%E5%89%A7%E5%9B%A2\)&action=edit&redlink=1 "肉罐头 (巨蟒剧团)（页面不存在）")而非传统的[foo和bar](https://zh.wikipedia.org/wiki/Foobar "Foobar")[^private-var-103]。

Python的[语句](https://zh.wikipedia.org/wiki/%E8%AA%9E%E5%8F%A5_\(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88\) "语句 (程序设计)")包括简单语句：

- [赋值](https://zh.wikipedia.org/wiki/%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5 "赋值语句")语句，采用的[中缀](https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95 "中缀表示法")记号是等号`=`。赋值语句被用来将名字绑定（含重新绑定）到值，以及用来修改[可变对象](https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1 "不可变对象")的[特性](https://zh.wikipedia.org/wiki/%E7%89%B9%E6%80%A7_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "特性 (计算机科学)")或项目。
- Python还支持[增广赋值](https://zh.wikipedia.org/wiki/%E5%A2%9E%E5%B9%BF%E8%B5%8B%E5%80%BC "增广赋值")语句[^104]，将一个二元运算和一个赋值语句合并成一个单一语句，例如`x += 1`。
- Python支持“序列解包”（sequence unpacking）[^105]：在等号左侧可以是一个表达式列表，其中每个表示式都可求值成能被赋值的东西（变量、可写特性等）；在等号右侧相应的是一个“可迭代”对象，它在被迭代时产生的值的数量，同于左手侧可写表达式的数量；赋值语句对这个对象进行迭代，将产生的每个值分别赋值给左侧对应的可赋值者。在等号右侧直接包装出序列解包所要求的元组，就形成了[并行赋值](https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E8%B5%8B%E5%80%BC "并行赋值")，可以同时给多个变量赋值，还可以交换两个变量的值。[^106]
- [表达式](https://zh.wikipedia.org/w/index.php?title=%E8%A1%A8%E8%BE%BE%E5%BC%8F_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\)&action=edit&redlink=1 "表达式 (计算机科学)（页面不存在）")语句，用来交互式的计算并写出一个值，或者用来调用一个过程（即返回无含义结果的函数），在Python中过程返回值`None`。
- `global`语句，是在整个当前代码块中成立的声明，它意味着随后列出的标识符被解释为全局变量。
- `nonlocal`语句，导致随后列出的标识符，提及在除了全局作用域之外的最近包围作用域中的先前绑定变量。
- `type`语句，介入于版本3.12，声明作为[类型别名类型](https://zh.wikipedia.org/wiki/%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81 "参数多态")（`typing.TypeAliasType`）的实例的一个类型别名。
- `pass`语句，充当[NOP](https://zh.wikipedia.org/wiki/NOP "NOP")，表示此行为空，不执行任何操作。
- `[assert](https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_\(%E7%A8%8B%E5%BC%8F\) "斷言 (程式)")`语句，用于编程调适阶段时测试执行条件是否满足。
- `continue`语句，越过这次迭代并继续进行下个项目。
- `break`语句，从循环中跳出。
- `return`语句，用来从函数返回值。当函数执行到`return`语句时，它会停止执行并将指定的值返回给调用者。
- `raise`语句，抛出一个例外。
- `yield`语句，使用它从一个[生成器](https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\)#Python "生成器 (计算机编程)")中返回一个值。在版本2.5之前，信息只能单向的从生成器传递出来。[^107]
- 自此版本2.5，重定义`yield`为表达式[^108]，通过它的返回值将信息传递进入生成器函数中[^autont-57-109]，从而能够支持[协程](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B "协程")功能[^autont-57-109]。[^110]`yield`语句在语义上等价于加圆括号的`yield`表达式[^111]。
- 自从版本3.3，提供了`yield from`语句，含有这个语句的“委托生成器”将其部分运算委托给另一个“子生成器”，将传入信息递送给它并直接回传它产生的值[^autont-58-112]。版本3.4在[异步I/O](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5I/O "异步I/O")框架中扩展了基于生成器的协程[^113]，这个扩展自从Python 3.8已经被弃用[^114]。
- 自从版本3.6，介入了生成`async for`语句所用的异步迭代器的异步生成器[^115]。
- `import`语句，导入一个模块或包，它组合了两种操作，查找指名的模块，接着将找到的结果绑定到在局部作用域中的名字。导入语句有三种形式（下述语句样本中的方括号表示其中内容为可选的）：
- `import 模块名字 [as 别名]`，找到一个模块，装载它，如果有需要的话初始化它；在这个导入语句出现的作用域的局部[命名空间](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4 "命名空间")中，定义一个名字或一些名字[^import-116]。
- `from 模块名字 import 定义1 [as 别名1], 定义2 [as 别名2], ...`，找到、装载、必需时初始化一个模块；接着在局部[命名空间](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4 "命名空间")中，增加到找到指名特性的引用[^import-116]。
- `from 模块名字 import *`，在导入语句出现的作用域的局部命名空间中，绑定模块中定义的所有公开的名字[^modules-117]。
- `del`语句，递归的进行删除。

复合语句：

- `[if](https://zh.wikipedia.org/wiki/%E6%A2%9D%E4%BB%B6%E9%81%8B%E7%AE%97%E5%BC%8F "條件運算式")`语句，当条件成立时执行语句包。它经常包含`elif`、`else`子句。
- `[while](https://zh.wikipedia.org/wiki/While%E8%BF%B4%E5%9C%88 "While迴圈")`语句，当条件为真时，重复执行语句包。
- `[for](https://zh.wikipedia.org/wiki/Foreach%E5%BE%AA%E7%8E%AF "Foreach循环")`语句，遍历列表、字符串、字典、集合等[迭代器](https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8 "迭代器")，依次处理迭代器中的每个元素。
- `match`语句，用于[模式匹配](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D "模式匹配")。
- `[try](https://zh.wikipedia.org/w/index.php?title=%E4%BE%8B%E5%A4%96%E5%A4%84%E7%90%86%E8%AF%AD%E6%B3%95&action=edit&redlink=1 "例外处理语法（页面不存在）")（英语：[Exception handling syntax](https://en.wikipedia.org/wiki/Exception_handling_syntax "en:Exception handling syntax")）`语句，它经常包含`except`、`else`、`finally`子句，处理在编程执行中出现的异常情况。Python支持并广泛使用[例外处理](https://zh.wikipedia.org/wiki/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86 "异常处理")，作为检测错误状况和程序中其他“例外”事件的方式，并提倡在可能出现错误状况的任何时候都使用例外。习惯上访问一个文件或资源不在使用之前进行测试，而是先行尝试使用它，再捕获访问被拒绝引发的例外。[^118]Python 3.11介入了`except*`子句[^119]。
- `with`语句，把一块代码包裹在一个上下文管理器之内。它允许了[资源获取即初始化](https://zh.wikipedia.org/wiki/RAII "RAII")（RAII）式行为，可替代常见的`try`/`finally`惯用法。Python使用`with`语句处理资源[^120]，在进入一个作用域的时候调用一个函数，而在离开它的时候调用另一个函数，例如：在一块代码执行之前获取一个[锁](https://zh.wikipedia.org/wiki/%E9%94%81_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "锁 (计算机科学)")，并且在此后释放这个锁；或事先打开一个[文件](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6 "计算机文件")，并且事后关闭它。[^121]
- `class`语句，是定义[类](https://zh.wikipedia.org/wiki/%E7%B1%BB_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "类 (计算机科学)")的可执行语句。类的继承列表给出基础类列表，没有继承列表的类，缺省继承基础类`object`。类的包接着在新的执行框架（frame）中执行，它使用新建的局部[命名空间](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4 "命名空间")和原来的全局命名空间。当这个类包完成执行之时，丢弃它的执行框架并保存它的局部命名空间。一个类对象接着被创建，其基础类采用继承列表，其特性字典采用保存的局部命名空间。类名字接着在原来的局部命名空间中，被绑定到这个类对象。
- `def`语句，是定义[函数](https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F "子程序")和[方法](https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "方法 (计算机科学)")的可执行语句。它的执行在当前局部[命名空间](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4 "命名空间")中，将函数名字绑定到一个函数对象（对函数的可执行代码的包装器）。这个函数对象包含到当前全局命名空间的引用，作为调用这个函数时使用的全局命名空间。
- `async def`语句，用于[协程](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B "协程")函数定义。`await`表达式、`async for`语句和`async with`语句，只能用在协程函数的主体中。[^122]

Python程序构造自代码[块](https://zh.wikipedia.org/wiki/%E5%9D%97_\(%E7%BC%96%E7%A8%8B\) "块 (编程)")。块是作为一个单元执行的Python程序文本，模块、函数主体和类定义都是块。交互式键入的每个命令、脚本文件和脚本命令都是代码块。传递给内置函数`eval()`和`exec()`执行的字符串是代码块。

代码块在执行框架（frame）中执行。框架包含一些用于调试的管理信息，并确定在这个代码块执行完成后，执行在何处以及如何继续。[命名空间](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4 "命名空间")是存储变量的地方，它被实现为字典。有局部命名空间、全局空间即包含此代码块的那个模块的命名空间，和内置命名空间即模块`builtins`的命名空间；对象的方法是定义在类主体内的函数，它有着嵌套的命名空间。命名空间通过防止命名冲突而支持了模块性，还通过明晰了哪个模块实现了哪个函数而增进可读性和可维护性。

[模块](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B "模块化编程")是包含Python定义和语句的一个文件，这个文件名字是模块名字附加上后缀`.py`；在一个模块中，模块的名字（作为字符串）可获得为全局变量`__name__`的值[^modules-117]。包（package）是可以包含子模块或递归性的子包的模块。包在技术上是具有`__path__`特性的Python模块。可以将包视为文件系统上的目录，而将模块视为这种目录中的文件，但是包和模块不必然源自文件系统[^123]。

完整的Python程序，在一个极小初始化的环境中执行：所有内置和标准模块均可获得，但除了`sys`（各种系统服务）、`builtins`（内置函数、[例外](https://zh.wikipedia.org/wiki/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86 "异常处理")和`None`）和`__main__`之外都未被初始化。`__main__`用来为完整程序的执行提供局部和全局名字。当解释器被调用在交互模态下的时候，它一次一个的读取并执行语句；初始环境同于完整程序，每个语句都在`__main__`的命名空间中执行。

顶层代码是启动运行的首个用户指定Python模块。`__main__`是顶层代码运行所在的环境。从命令行使用`-m`参数，作为顶层脚本运行的模块（作为模块`__main__`）是代码块。此时`__name__`变量被设置为`"__main__"`，籍此可在这个模块中增加直接运行时候执行的代码[^modules-117][^124]。

名字是通用的引用持有者，它不关联于一个固定的[数据类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")，但是，一个名字在给定时间，总是被[绑定](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E7%BB%91%E5%AE%9A "名字绑定")到有一个类型的某个对象上，这就是[动态类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")的特征。名字的存储位置不“包含”所指示的值，一个共同的值可以赋值给多个名字，一个名字在任何时候，都可以重新绑定到各种不同类型的对象上，包括字符串、过程、具有数据和方法的复杂对象等。如果一个名字绑定在一个[块](https://zh.wikipedia.org/wiki/%E5%9D%97_\(%E7%BC%96%E7%A8%8B\) "块 (编程)")中，它是这个块的[局部变量](https://zh.wikipedia.org/wiki/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F "局部变量")，除非被声明为`nonlocal`或`global`。如果一个名字绑定在模块层次，它是[全局变量](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F "全局变量")。模块代码块的变量，既是局部的也是全局的。如果一个变量使用在一个代码块中，却不定义在这里，它是[自由变量](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F "自由变量")[^naming&binding-125]。

内置`vars()`函数，返回一个模块、类、实例或任何具有字典特性`__dict__`的对象的字典特性。内置`globals()`函数，返回实现当前模块的命名空间的一个字典。内置`locals()`函数，更新并返回表示当前局部符号表的一个字典。在函数块中而非类块中调用`locals()`之时，它返回自由变量。在模块层级上，`locals()`和`globals()`返回同一个字典。内置`dir()`函数，在无参数时，返回在当前局部作用域内的名字列表；在有一个参数时，尝试返回这个对象的有效特性的列表。[^126]

在Python中赋值所进行的操作，是将一个名字[绑定](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E7%BB%91%E5%AE%9A "名字绑定")为到一个分立的动态分配的[对象](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "对象 (计算机科学)")的一个[引用](https://zh.wikipedia.org/wiki/%E6%8C%87%E9%92%88_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\) "指针 (计算机编程)")。除了在块中出现的每个赋值语句或导入语句之外，下列构造也绑定名字：给函数的形式参数、类定义、函数定义、赋值表达式、在`for`语句头部中和各种`as`关键字之后的标识符目标（target），`as`关键字出现在`import`语句、`with`语句、`except`子句、`except*`子句和结构式模式匹配的`as`模式之中。

[作用域](https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F "作用域")定义一个名字在一个[块](https://zh.wikipedia.org/wiki/%E5%9D%97_\(%E7%BC%96%E7%A8%8B\) "块 (编程)")中的可见性。如果一个局部变量被定义在一个块中，它的作用域包括这个块。如果这个定义出现在一个函数块中，作用域扩展到在所界定作用域内包含的任何块，除非所包含的块为这个名字介入了不同的绑定。当一个名字在一个代码块之中使用，它采用最近包围作用域来解析。对一个代码块可见的所有这种作用域的集合，叫做这个这个块的“环境”[^naming&binding-125]。

如果一个名字绑定在一个块中，并且在其中于绑定之前就被使用，会导致一个错误。[^127] 如果`global`语句出现在一个块之中，在这个语句中指定的所有名字，提及在顶层命名空间中这些名字的绑定。名字在顶层命名空间解析，首先查找全局[命名空间](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4 "命名空间")，未果查找内置命名空间。`global`语句与在同一个块中的名字绑定运算有同样的作用域。如果一个自由变量的最近包围作用域包含针对它的`global`语句，这个自由变量被当作全局的[^naming&binding-125]。[^128] 当一个函数或类的定义被嵌套到其他函数的定义之内，它的非局部作用域就是这个包围函数的局部作用域。`nonlocal`语句导致其列出的标识符，提及在非局部作用域内先前绑定的名字（即[非局部变量](https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&action=edit&redlink=1 "非局部变量（页面不存在）")）[^naming&binding-125]。[^129]

Python中很多[表达式](https://zh.wikipedia.org/w/index.php?title=%E8%A1%A8%E8%BE%BE%E5%BC%8F_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\)&action=edit&redlink=1 "表达式 (计算机科学)（页面不存在）")与[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言和[java](https://zh.wikipedia.org/wiki/Java "Java")类似，而另一些则与之不同。

- 在Python中，[算术](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF "算术")运算的加法`+`、减法`-`、乘法`*`和[取模](https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4 "模除")`%`是与[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言和[java](https://zh.wikipedia.org/wiki/Java "Java")相同的，但是除法的行为不同。在Python中有两种除法，它们是[下取整](https://zh.wikipedia.org/wiki/%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0 "取整函数")除法（或整数除法）`//`和浮点除法`/`。Python增加了指数算符`**`。自从Python 3.5，介入了[矩阵乘法](https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95 "矩阵乘法")算符`@`[^pep465-130]，它已经用于了[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")库[^131]。

- 在Python中，有如下必须用于整数的[位](https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C "位操作")运算：`&`与（AND），`|`或（OR），`~`非（NOT），`^`异或（XOR），`>>`右移, `<<`左移。

- 在Python中，有如下[比较](https://zh.wikipedia.org/wiki/%E9%97%9C%E4%BF%82%E9%81%8B%E7%AE%97%E5%AD%90 "关系运算符")运算：大于`>`，小于`<`，等于`==`，不等于`!=`，小于等于`<=`，大于等于 `>=`。`==`按值比较。Python的`is`、`is not`算符可以用来比较对象的同一性（按引用比较），也就是比较两个变量是否引用了同一个对象。而`in`、`not in`用于判断一个对象是否属于另外一个对象。在Python中，比较是可以链接起来的[^compare-132]，比如`a < b < c`。

- Python使用`and`、`or`、`not`表示[逻辑](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0 "逻辑代数")运算与、或、非，不采用[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言和[Java](https://zh.wikipedia.org/wiki/Java "Java")中所用的符号`&&`、`||`、`!`。

- 在Python中，由逗号`,`分隔的一组表达式，叫做表达式列表。Python为构造列表、字典或集合，提供了叫做“显示”的特殊语法，它们每个都有两种方式：包容内容要么显式列举出来；要么通过一组循环和过滤指令计算而来，这叫做“推导式”。列表显示是包围在方括号中的可以为空的一系列表达式，一个例子列表可写为`[1,2,3]`。字典显示是包围在花括号中的可能为空的一系列的键/数据项对。集合显示用花括号来指示，与字典显示的区别是缺少分隔键与值的分号[^133]。自从Python 3.5，增加了在表达式列表中的“可迭代解包”`*`，和在字典显示中的“字典解包”`**`[^134]。[^135]

- Python支持[列表推导式](https://zh.wikipedia.org/wiki/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F "列表推导式")。[^136]Python 2.4将列表推导式扩展至更一般性的[生成器表达式](https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\)#Python "生成器 (计算机编程)")[^autont-59-137]。[^138]Python 3.0又增补了[字典推导式](https://zh.wikipedia.org/wiki/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F#%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F "列表推导式")和[集合推导式](https://zh.wikipedia.org/wiki/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F#%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC%E5%BC%8F "列表推导式")。[^139]

- 在Python中，加圆括号形式（parenthesized form），是包围在圆括号中的一个可选表达式列表。加圆括号的表达式列表产生的东西，就是这个表达式列表所产生的：如果这个列表包含至少一个逗号，它产生一个元组；否则它产生构成这个表达式列表的那个单一表达式[^140]。一个例子元组可写为`(1,2,3)`。元组不是圆括号形成的，而是使用逗号形成的，在没有歧义的情况下，元组的圆括号是可选的。空的圆括号对产生空元组对象。使用序列串接算符`+`来串接二个元组，产生包含给定元组二者的元素的一个新元组。

- Python支持在序列对象（比如字符串、元组或列表）上的[下标](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84 "数组")（subscription）表达式：`a[索引]`，和[分片](https://zh.wikipedia.org/w/index.php?title=%E9%98%B5%E5%88%97%E5%88%86%E7%89%87&action=edit&redlink=1 "阵列分片（页面不存在）")表达式：`a[开始:停止]`或`a[开始:停止:步长]`。下标索引是[基于零](https://zh.wikipedia.org/wiki/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E7%9A%84%E7%B7%A8%E8%99%9F "从零开始的编号")的，负数是相对于结尾的。分片范围自从“开始”索引，直到但不包括“停止”索引。分片的第三个参数叫做“步长”（step）或“间隔”（stride），允许元素被跳过和用负数指示反向。分片索引可以省略，例如`a[:]`，这返回整个列表的一个复本。[^141]分片的每个元素都是[浅层复制](https://zh.wikipedia.org/w/index.php?title=%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6&action=edit&redlink=1 "对象复制（页面不存在）")的。

- Python的[条件表达式](https://zh.wikipedia.org/wiki/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6 "条件运算符")表示为`x if c else y`。意思是当`c`为真时，表达式的值为`x`，否则表达式的值为`y`。 在运算元的次序上不同于很多其他语言中常见的`c ? x : y`。

- Python的[匿名函数](https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0 "匿名函数")实现为`lambda`表达式。匿名函数体只能是一个表达式。[^142]

- 自从Python 3.8，介入了赋值表达式，其记号是`:=`[^assign-64]。它将一个表达式赋值给一个标识符，同时还返回这个表达式的值。赋值表达式在用作子表达式，即位于分片表达式、条件表达式、`lambda`表达式、关键字参数中的表达式和推导式中的`if`表达式之中，以及在`assert`和`with`语句之中的时候，必须围绕着圆括号。在它们可以使用的所有其他地方，包括在`if`和`while`语句之中，都不要求圆括号[^143]。

Python中[运算符](https://zh.wikipedia.org/wiki/%E7%AE%97%E5%AD%90_\(%E7%BC%96%E7%A8%8B\) "算子 (编程)")具有[优先级](https://zh.wikipedia.org/wiki/%E9%81%8B%E7%AE%97%E6%AC%A1%E5%BA%8F "运算次序")，下表中的运算符按照从最高到最低的次序列出。在相同单元格中运算符具有相同的优先级，它们从左至右结合，除了指数表达式和条件表达式从右至左结合之外[^144]：

| 运算符 | 描述 |
| --- | --- |
| `(表达式...)`，`[表达式...]`，`{键: 值...}`，`{表达式...}` | 加圆括号表达式，列表显示，字典显示，集合显示 |
| `x[索引]`，`x[索引:索引]`，`x(参数...)`，`x.特性` | 下标，分片，调用，特性引用 |
| `await x` | `await`表达式 |
| `**` | 指数 |
| `+x`，`-x`，`~x` | 取原数，相反数，逐位NOT |
| `*`，`@`，`/`，`//`，`%` | 乘法，矩阵乘法，除法，下取整除法，余数 |
| `+`，`-` | 加法和减法 |
| `<<`，`>>` | 移位 |
| `&` | 逐位AND |
| `^` | 逐位XOR |
| `\|` | 逐位OR |
| `in`，`not in`，`is`，`is not`，`<`，`<=`，`>`，`>=`，`!=`，`==` | 包含成员关系测试，同一测试，各种比较 |
| `not x` | 布尔NOT |
| `and` | 布尔AND |
| `or` | 布尔OR |
| `if – else` | 条件表达式 |
| `lambda` | lambda表达式 |
| `:=` | 赋值表达式 |

Python提供了序列串接算符`+`和序列倍增算符`*`[^145]。自从Python 3.9，介入了字典归并算符`|`和字典更新算符`|=`[^146]。

Python的文本序列类型，包括字符串`str`和字节序列`bytes`与`bytearray`。[字符串文字](https://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97&action=edit&redlink=1 "字符串文字（页面不存在）")有多种写法，字符串对象有一个内置格式算符`%`：

- 短字符串文字，由单引号`'`或双引号`"`界定。不同于[Unix shell](https://zh.wikipedia.org/wiki/Unix_shell "Unix shell")、[Perl](https://zh.wikipedia.org/wiki/Perl "Perl")和受Perl影响的语言，单引号和双引号功能相同。这二种字符串都使用反斜杠`\`作为[转义字符](https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6 "转义字符")。

- 长字符串文字，是开始并结束于三个单引号`'''`或三个双引号`"""`的序列。它们可以跨越多行，其功能就像[shell](https://zh.wikipedia.org/wiki/Unix_shell "Unix shell")、[Perl](https://zh.wikipedia.org/wiki/Perl "Perl")和[Ruby](https://zh.wikipedia.org/wiki/Ruby "Ruby")中的[here文档](https://zh.wikipedia.org/wiki/Here%E6%96%87%E6%A1%A3 "Here文档")。[^147]

- [字节](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82 "字节")[文字](https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E5%AD%97_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\)&action=edit&redlink=1 "文字 (计算机编程)（页面不存在）")总是前缀上一个`b`或`B`，它产生`bytes`类型的实例。它们只可以包含[ASCII](https://zh.wikipedia.org/wiki/ASCII "ASCII")字符，具有128或更大数值的字节必须通过转义来表达。

- 字符串文字或字节文字都可选的能前缀上一个`r`或`R`，这叫做[原始字符串](https://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97&action=edit&redlink=1 "字符串文字（页面不存在）")。转义序列不被解释，因此在文字反斜杠常见的地方很有用，比如[正则表达式](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F "正则表达式")和[Windows](https://zh.wikipedia.org/wiki/Microsoft_Windows "Microsoft Windows")风格的路径。[^148]这种引述可比较于[C#](https://zh.wikipedia.org/wiki/C%E2%99%AF "C♯")中的“`@`引述”。

- Python允许多个毗邻的字符串文字或字节文字（它们以空白分界并可以使用不同的引述约定），在编译时间于语法层面上串接起来。要在运行时间串接字符串，必须使用序列串接算符`+`[^149]。[^150]

- Python中的“字符串格式”算符`%`，在功能上类同于[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言中的`printf`[格式化字符串](https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2 "格式化字符串")[^151]，例如`"spam=%s eggs=%04d" % ("blah", 2)`，求值为`'spam=blah eggs=0002'`。自从Python 3.0，`str`类提供了可供替代的`format()`方法[^152]，例如`"spam={0} eggs={1:04d}".format("blah", 2)`。在Python 3.6中，提供了“格式化字符串文字”或称为“f字符串”，它向字符串文字前缀上`f`或`F`[^153]，这是一种[字符串插值](https://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC&action=edit&redlink=1 "字符串插值（页面不存在）")[^pep-0498-154]，例如`x="blah"; y=2; f'spam={x} eggs={y:04d}'`。[^155]

在Python中，在表达式和语句之间的区别是严格强制性的，这对比于语言如[Common Lisp](https://zh.wikipedia.org/wiki/Common_Lisp "Common Lisp")、[Scheme](https://zh.wikipedia.org/wiki/Scheme "Scheme")或[Ruby](https://zh.wikipedia.org/wiki/Ruby "Ruby")。故而Python中个别构造存在功能重复，比如：[列表推导式](https://zh.wikipedia.org/wiki/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F "列表推导式")相当`for`循环；[条件](https://zh.wikipedia.org/wiki/%E6%A2%9D%E4%BB%B6%E9%81%8B%E7%AE%97%E5%BC%8F "条件表达式")表达式相当`if`语句；内置函数`eval()`相当`exec()`，前者用于表达式，后者用于语句。

语句不能成为表达式的一部分，由于列表和其他推导式或[lambda表达式](https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0 "匿名函数")，都是表达式，也就不能包含语句。这个限制的一个示例：赋值语句比如`a = 1`，不能用作条件语句的条件判断表达式的一部分；这能够避免C语言编程中的一个常见错误，即在条件判断时把等于算符`==`误写为赋值算符`=`，这不是预期代码却在语法上有效而能通过编译器检查，在Python中这会导致一个语法错误。

Python的函数支持[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92 "递归")和[闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "闭包 (计算机科学)")[^156]，及其他[头等函数](https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0 "头等函数")特征，但不支持[函数重载](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD "函数重载")。Python的函数作为[头等对象](https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%AF%B9%E8%B1%A1 "头等对象")，具有和普通对象平等的地位。Python官方实现不提供[尾调用](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8 "尾调用")优化或[头等续体](https://zh.wikipedia.org/wiki/%E7%BB%AD%E4%BD%93 "续体")，吉多·范罗苏姆曾声称永远都不会加以支持[^autont-55-157]，但有第三方库支持[弹跳床](https://zh.wikipedia.org/w/index.php?title=%E5%BC%B9%E8%B7%B3%E5%BA%8A_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD\)&action=edit&redlink=1 "弹跳床 (计算机术语)（页面不存在）")[^158]。

Python可以在函数定义时，于形式参数序列中，指定[形式参数缺省值](https://zh.wikipedia.org/wiki/%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0 "缺省参数")，即以`param=value`样式进行一次性初始化。形式参数在初始化之后，保持既有绑定；函数的后续调用，可继续对它进行访问或变更。[^159]为有缺省值的形式参数提供实际参数，在函数调用时是可选的。

Python的函数实际参数与形式参数之间的结合，是传递“对象引用”，函数在被调用的时候，给函数调用的实际参数，被介入到一个局部符号表中，实际参数使用传值调用来传递，而这个值总是对象引用，而非这个对象的值[^160]。如果形式参数绑定到一个可变的对象，则通过形式参数对此对象内容的修改，在函数外也是可见的。如果形式参数绑定到一个不可变的对象，则通过形式参数是不能修改此对象内容，但可以把形式参数重新绑定到其它对象上，这并不影响函数外的对象的值。[^161]

Python支持位置实际参数和关键字实际参数。函数调用时，实际参数可以如同C语言那样，按照位置与形式参数匹配；也可以采用[命名参数](https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0 "命名参数")或称为关键字实际参数，即`kwarg=value`样式的实际参数。使用不对应实际参数的特殊形式参数`/`和`*`，可以将参数序列分为三部分：唯位置参数[^162]、可位置可关键字参数和唯关键字参数。有缺省值的形式参数之后，不能跟随无缺省值的可位置形式参数。[^163]在一个函数调用的实际参数序列中，关键字实际参数必须出现在位置实际参数之后。

在位置和关键字形式参数序列末尾，可以分别有`*args`或`**kwargs`这样的形式参数，它们对应于在函数调用时提供的，超出形式参数序列规定而无所对应的多个实际参数；在形式参数名字前加一个`*`号，该形式参数`args`是`tuple`类型，对应可变量目的位置实际参数；在形式参数名字前加`**`号，该形式参数`kwargs`是`dict`类型，对应可变量目的关键字实际参数。[^164]如果位置实际参数已经在一个序列类型如列表或元组的对象中，在引用它的变量前加一个`*`号传递给函数，则其中所有元素解包为多个位置实际参数；如果关键字实际参数在字典中，则加`**`号来传递给函数。

修饰器（decorator）可用来修改一个函数、方法或类定义的任何可调用Python对象。将已定义的原来对象传递给修饰器，它返回一个修改后的对象，接着把它绑定到在定义中那个名字。Python修饰器部分受到[Java注解](https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3 "Java注解")的影响，而有类似的语法；修饰器语法是纯粹的[语法糖](https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96 "语法糖")，使用`@`作为关键字形成修饰符。修饰器是一种形式的[元编程](https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B "元编程")，它们增强它们所修饰的函数或方法的行动。[^165] 多个修饰器可以链接起来，通过在毗连的行上放置多个修饰符，或者使用中间变量。[^166] 函数修饰器的正规用法包括：用来建立[类方法](https://zh.wikipedia.org/wiki/%E7%B1%BB%E6%96%B9%E6%B3%95 "类方法")或[静态方法](https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95 "静态方法")[^decorator-57]、设置[先决条件](https://zh.wikipedia.org/wiki/%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6 "先决条件")和[后置条件](https://zh.wikipedia.org/wiki/%E5%90%8E%E7%BD%AE%E6%9D%A1%E4%BB%B6 "后置条件")、实现[多方法](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%88%86%E6%B4%BE#Python "多分派")、增加函数特性、[跟踪](https://zh.wikipedia.org/w/index.php?title=%E8%B7%9F%E8%B8%AA_\(%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "跟踪 (软件)（页面不存在）")、[同步](https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5 "同步")[^167]；此外更远大的用法包括：[尾调用消除](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8 "尾调用")、[记忆化](https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96 "记忆化")[^168]。

为了增强代码的可读性，可以在函数后书写“文档字符串”（简称docstrings），用于解释函数的作用、参数的类型与意义、返回值类型与取值范围等。可以使用内置函数`help()`，打印出函数的使用帮助。[^169]自从Python 3.0，函数可以对参数与返回值增加类型标注[^170]。此特性可方便对源代码进行更深入的分析。[^171]自从Python 3.5，开始支持类型提示[^pep484-172]。

Python支持大多数[面向对象编程](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B "面向对象编程")技术。在Python中所有东西都是对象，包括[类](https://zh.wikipedia.org/wiki/%E7%B1%BB_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "类 (计算机科学)")、函数、数和[模块](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B "模块化编程")。它允许[多态性](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%80%81_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "多态 (计算机科学)")，不只是在[类层级](https://zh.wikipedia.org/w/index.php?title=%E7%B1%BB%E5%B1%82%E7%BA%A7&action=edit&redlink=1 "类层级（页面不存在）")之内，而且通过采用[鸭子类型](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B "鸭子类型")的方式[^duck-5]。任何[对象](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "对象 (计算机科学)")可以用于任何[类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")，只要它有适当的[方法](https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "方法 (计算机科学)")和[特性](https://zh.wikipedia.org/wiki/%E7%89%B9%E6%80%A7_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "特性 (计算机科学)")（attribute）就能工作。Python天然支持[类](https://zh.wikipedia.org/wiki/%E7%B1%BB_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "类 (计算机科学)")的[继承](https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "继承 (计算机科学)")包括[多重继承](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF "多重继承")，为此采用[C3线性化](https://zh.wikipedia.org/wiki/C3%E7%BA%BF%E6%80%A7%E5%8C%96 "C3线性化")或方法决定次序（MRO）算法，还支持[混入](https://zh.wikipedia.org/wiki/Mixin "Mixin")。Python支持[元类](https://zh.wikipedia.org/wiki/%E5%85%83%E7%B1%BB "元类")[^autont-13-173]，自从Python 3.6，提供了定制类创建的简单机制[^174]。

Python使用[名字修饰](https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0 "名字修饰")，有限的支持私有变量。对象的（可写）特性可以被提取为一个字典[^175]。在Python中，不强制使用[访问子](https://zh.wikipedia.org/wiki/%E5%8F%98%E5%BC%82%E5%AD%90%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AD%90 "变异子与访问子")与[变异子](https://zh.wikipedia.org/wiki/%E5%8F%98%E5%BC%82%E5%AD%90%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AD%90 "变异子与访问子")方法，来访问[数据成员](https://zh.wikipedia.org/wiki/%E5%AD%97%E6%AE%B5 "字段")的面向对象编程信条。就像Python提供函数式编程构造，但不尝试要求[参照透明性](https://zh.wikipedia.org/w/index.php?title=%E5%8F%82%E7%85%A7%E9%80%8F%E6%98%8E%E6%80%A7&action=edit&redlink=1 "参照透明性（页面不存在）")一样，它提供对象系统，但不要求面向对象编程行为。

[对象](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "对象 (计算机科学)")的[方法](https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "方法 (计算机科学)")，是附属于这个对象的[类](https://zh.wikipedia.org/wiki/%E7%B1%BB_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "类 (计算机科学)")的函数。对于正常的方法和函数，语法`instance.method(arguments)`，是`Class.method(instance, arguments)`的[语法糖](https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96 "语法糖")。Python的方法有显式的`[self](https://zh.wikipedia.org/w/index.php?title=This_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\)&action=edit&redlink=1 "This (计算机编程)（页面不存在）")（英语：[this (computer programming)](https://en.wikipedia.org/wiki/this_\(computer_programming\) "en:this (computer programming)")）`形式参数，用来访问[实例数据](https://zh.wikipedia.org/wiki/%E5%AD%97%E6%AE%B5 "字段")；这借鉴自[Modula-3](https://zh.wikipedia.org/wiki/Modula-3 "Modula-3")，对立于隐式的`self`或`[this](https://zh.wikipedia.org/w/index.php?title=This_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\)&action=edit&redlink=1 "This (计算机编程)（页面不存在）")（英语：[this (computer programming)](https://en.wikipedia.org/wiki/this_\(computer_programming\) "en:this (computer programming)")）`关键字，它们用在其他一些面向对象编程语言，比如[C++](https://zh.wikipedia.org/wiki/C%2B%2B "C++")、[Java](https://zh.wikipedia.org/wiki/Java "Java")、[Objective-C](https://zh.wikipedia.org/wiki/Objective-C "Objective-C")或[Ruby](https://zh.wikipedia.org/wiki/Ruby "Ruby")之中[^autont-61-176]。在Python中，`self`可以被看作是一个习惯用法，它可以被换为任何其它合法的参数名。[^177]

Python提供了`super()`内置函数，在一个类的方法中调用此函数返回一个代理（proxy）对象，它将其方法调用[委托](https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98_\(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\) "委托 (面向对象编程)")给这个类的父类或兄弟类[^super-178]，当一个[子类](https://zh.wikipedia.org/wiki/%E5%AD%90%E7%B1%BB "子类")的方法[覆盖](https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96 "方法覆盖")了[超类](https://zh.wikipedia.org/wiki/%E8%B6%85%E7%B1%BB "超类")方法的时候，可通过调用`super().method`，来调用与子类的`self.method`方法同名超类方法。[^179] Python支持一些以`__`开始和结束的特殊方法名，它们用于实现[运算符重载](https://zh.wikipedia.org/wiki/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD "运算符重载")，以及实现多种特殊功能[^special-method-names-75]。在Python中，可以通过定义特殊方法来重载运算符，比如在一个类上定义`__add__()`，将允许在这个类的实例上使用`+`算符。

在Python中，定义了一个或多个特殊方法`__get__()`、`__set__()`、`__delete__()`的类，可以用作描述器（descriptor）[^180]。建立一个描述器的实例，作为另一个类的一个类成员，使得这个实例成为此另一个类的[属性](https://zh.wikipedia.org/wiki/%E5%B1%9E%E6%80%A7_\(%E7%BC%96%E7%A8%8B\) "属性 (编程)")（property）。使用与[特性](https://zh.wikipedia.org/wiki/%E7%89%B9%E6%80%A7_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "特性 (计算机科学)")（attribute）访问相同的语法，访问一个实例对象中的这个成员属性。[^181]

Python允许通过使用`@classmethod`和`@staticmethod`修饰符，来分别建立[类方法](https://zh.wikipedia.org/wiki/%E7%B1%BB%E6%96%B9%E6%B3%95 "类方法")和[静态方法](https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95 "静态方法")[^decorator-57]。给类方法的第一个实际参数，是对类对象的引用，而非对实例的`self`引用。静态方法没有特定的第一个实际参数，实例或类对象，都不固定的传递给静态方法。[^182] Python的`property`内置函数，将一个类中特殊定义的访问一个特性的那些方法，包装成的这个类的一个属性[^183]。[^184]

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c4/Python_3._The_standard_type_hierarchy-en.svg/340px-Python_3._The_standard_type_hierarchy-en.svg.png)

Python 3的标准类型层级[^185]

Python使用[鸭子类型](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B "鸭子类型")，并拥有有类型的对象，和无类型的变量名字。在[编译期](https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E6%9C%9F "编译期")不检查类型约束，而宁愿在一个对象上的操作出现可能的失败，表现出这个给定对象不具有适合的类型。尽管是[动态类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")系统，Python却是[强类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")的，禁止没有明确定义的操作（比如加一个数到一个字符串），而不是默默的去尝试转换使其有意义。Python支持广泛的类型和类的[内省](https://zh.wikipedia.org/wiki/%E5%86%85%E7%9C%81_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "内省 (计算机科学)")。类型是`type`的实例，可以被读取和比较。

Python有着范围广泛的基本数据类型。同时具备常规的整数和[浮点](https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E6%95%B0 "浮点数")算术，它透明的支持[任意精度算术](https://zh.wikipedia.org/wiki/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97 "高精度计算")、[复数](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_\(%E6%95%B0%E5%AD%A6\) "复数 (数学)")和[十进制浮点数](https://zh.wikipedia.org/w/index.php?title=%E5%8D%81%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9&action=edit&redlink=1 "十进制浮点（页面不存在）")。Python支持种类繁多的字符串操作。在Python中，字符串是[不可变](https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1 "不可变对象")的，所以在其他编程语言中可能就地改变字符串的字符串操作，比如字符替换，在Python中返回新的字符串。

Python有一个非常有用特征，就是[搜集](https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "集合 (计算机科学)")（或称[容器](https://zh.wikipedia.org/wiki/%E5%AE%B9%E5%99%A8_\(%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\) "容器 (数据类型)")）类型的概念。一般的说，搜集是以一种易于引用或索引的方式，包含其他对象的对象。搜集有二种基本形式：序列和映射。Python对建立容器类型的对象有着语法上的支持。[^186]Python还提供了广泛的搜集操纵能力，比如内置的包含元素检查和通用迭代[协议](https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE_\(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\) "协议 (面向对象编程)")。

有次序的序列类型是列表（动态[数组](https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&action=edit&redlink=1 "数组数据类型（页面不存在）")）、[元组](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84 "多元组")和字符串。所有序列类型都是位置索引的（从`0`到`长度−1`），并且除了字符串，都可以包含任意类型的对象，在同一个序列中包括多种类型的对象。字符串和元组是不可变的，使得它们成为字典的键的完美候选者。在另一方面，列表是可变的，元素可以被插入、删除、修改、添加或[就地](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95 "原地算法")排序。

在另一方面，映射是以“字典”形式实现的无次序的类型，它将一组[不可变](https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1 "不可变对象")的键，映射到相应的元素上（非常像数学函数）。在字典中的键，必须是不可变的Python类型，比如整数或字符串，因为在底层它们是通过[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0 "散列函数")实现的。字典还是语言内部的中心，因为它们居于所有Python对象和类的核心：在变量名字（字符串）和这个名字所引用的值之间的映射，就存储为字典，而这些字典可以通过对象的`__dict__`特性直接访问。

[集合](https://zh.wikipedia.org/w/index.php?title=%E9%9B%86%E5%90%88_\(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\)&action=edit&redlink=1 "集合 (抽象数据类型)（页面不存在）")搜集类型，在版本2.4中被增加入语言核心。集合是无索引、无次序的搜集，它包含唯一性的不可变对象作为元素，并且实现了[集合论](https://zh.wikipedia.org/wiki/%E6%9C%B4%E7%B4%A0%E9%9B%86%E5%90%88%E8%AE%BA "朴素集合论")运算，比如[并集](https://zh.wikipedia.org/wiki/%E5%B9%B6%E9%9B%86 "并集")`|`、[交集](https://zh.wikipedia.org/wiki/%E4%BA%A4%E9%9B%86 "交集")`&`、[相对补集](https://zh.wikipedia.org/wiki/%E8%A1%A5%E9%9B%86#%E7%9B%B8%E5%AF%B9%E8%A1%A5%E9%9B%86 "补集")`-`、[对称差](https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%B7%AE "对称差")`^`，和[子集](https://zh.wikipedia.org/wiki/%E5%AD%90%E9%9B%86 "子集")测试`<=`、[真子集](https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%AD%90%E9%9B%86 "真子集")测试`<`、[超集](https://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86 "超集")测试`>=`、[真超集](https://zh.wikipedia.org/wiki/%E5%AD%90%E9%9B%86#%E5%AE%9A%E4%B9%89 "子集")测试`>`。有二种类型的集合：可变的`set`和不可变的`frozenset`。

Python允许编程者使用[类](https://zh.wikipedia.org/wiki/%E7%B1%BB_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "类 (计算机科学)")，定义自己的类型[^unify-53]，类是在[面向对象编程](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B "面向对象编程")中最经常使用的。类的新[实例](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "对象 (计算机科学)")，是通过调用这个类的[构造器](https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E5%99%A8 "构造器")而创建的，而类都是[元类](https://zh.wikipedia.org/wiki/%E5%85%83%E7%B1%BB "元类")`type`的实例，`type`是`type`元类自身的实例，这允许了[元编程](https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B "元编程")和[反射](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84%E5%BC%8F%E7%BC%96%E7%A8%8B "反射式编程")。[^187]

在版本3.0之前，Python有两种类：旧式的和新式的[^classy-188]。二种样式的语法是一样的，不同在于是否直接或间接的继承自类`object`，所有新式类都从`object`继承，并且是`type`的实例。在Python 2系列2.2以上，二种类都可以使用[^unify-53]。在Python 3.0中淘汰了旧式类。

长期规划是支持[渐进类型](https://zh.wikipedia.org/w/index.php?title=%E6%B8%90%E8%BF%9B%E7%B1%BB%E5%9E%8B&action=edit&redlink=1 "渐进类型（页面不存在）")[^pep483-7]，并且自从Python 3.5，语言的语法允许指定静态类型，但在缺省实现CPython中不检查它们[^pep484-172]。有叫做“mypy”的可选的静态类型检查器，支持编译期类型检查[^mypy-189]。

<table><caption>Python 3内置类型小结</caption><tbody><tr><th>类型</th><th><a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">可变性</a></th><th>描述</th><th>语法例子</th></tr><tr><td><code>bool</code></td><td>不可变</td><td><a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E7%88%BE%E5%80%BC">布尔值</a>，有表示值<code>False</code>和<code>True</code>的两个对象。作为整数类型<code>numbers.Integral</code>的子类型，它们在几乎所有上下文中，表现得如同<code>0</code>和<code>1</code>，除了在转换成字符串时转换为<code>"False"</code>和<code>"True"</code>之外。</td><td><code><span>True</span></code><br><code><span>False</span></code></td></tr><tr><td><code>int</code></td><td>不可变</td><td><a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">整数</a>，其大小在理论上无限制，实际上受限于内存<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-pep0237-190"><span>[</span>154<span>]</span></a></sup>。</td><td><code><span>42</span></code></td></tr><tr><td><code>float</code></td><td>不可变</td><td><a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8">双精度</a><a href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a>，确切精度依赖于机器。一般实现为<a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a>标准<a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8">binary64</a>浮点数，它有53个<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97">有效</a><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E4%BD%8D_(%E6%95%B0%E5%AD%A6)">数位</a>精度<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-191"><span>[</span>155<span>]</span></a></sup>。</td><td><code><span>1.414</span></code></td></tr><tr><td><code>complex</code></td><td>不可变</td><td><a href="https://zh.wikipedia.org/wiki/%E8%A4%87%E6%95%B8_(%E6%95%B8%E5%AD%B8)">复数</a>，即分别表示实部与虚部的两个双精度浮点数的<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>。</td><td><code><span>3</span><span>+</span><span>2.7</span><span>j</span></code></td></tr><tr><td><code>range</code></td><td>不可变</td><td>数的序列，通常用在<code>for</code>循环中指定循环次数<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-192"><span>[</span>156<span>]</span></a></sup>。</td><td><code><span>range</span><span>(</span><span>1</span><span>,</span> <span>10</span><span>)</span></code><br><code><span>range</span><span>(</span><span>10</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>-</span><span>2</span><span>)</span></code></td></tr><tr><td><code>str</code></td><td>不可变</td><td><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>，即<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E9%BB%9E">代码点</a>序列。字符串中的代码点都在范围<code>U+0000..U+10FFFF</code>之内。Python没有<code>char</code>类型，这些代码点都表示为长度为<code>1</code>的字符串对象。</td><td><div><pre><span></span><span>'Wikipedia'</span>
<span>"Wikipedia"</span>
<span>"""Spanning</span>
<span>multiple lines"""</span>
</pre></div></td></tr><tr><td><code>bytes</code></td><td>不可变</td><td rowspan="2"><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>序列，其项目是8位字节，用范围<code>0 &lt;= x &lt; 256</code>的整数表示。</td><td><code><span>b</span><span>'Some ASCII'</span></code><br><code><span>b</span><span>"Some ASCII"</span></code><br><code><span>bytes</span><span>([</span><span>0x53</span><span>,</span> <span>0x74</span><span>,</span> <span>0x72</span><span>])</span></code></td></tr><tr><td><code>bytearray</code></td><td>可变</td><td><code><span>bytearray</span><span>(</span><span>b</span><span>'Some ASCII'</span><span>)</span></code><br><code><span>bytearray</span><span>(</span><span>b</span><span>"Some ASCII"</span><span>)</span></code><br><code><span>bytearray</span><span>([</span><span>0x53</span><span>,</span> <span>0x74</span><span>,</span> <span>0x72</span><span>])</span></code></td></tr><tr><td><code>list</code></td><td>可变</td><td><a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E5%88%97_(%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)">列表</a>，可以包含任意的Python对象。</td><td><code><span>[</span><span>4.0</span><span>,</span> <span>'string'</span><span>,</span> <span>True</span><span>]</span></code><br><code><span>[]</span></code></td></tr><tr><td><code>tuple</code></td><td>不可变</td><td><a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%BB%84">元组</a>，可以包含任意的Python对象。只有一个项目的元组，可以通过向表达式后缀一个逗号来形成。</td><td><code><span>(</span><span>4.0</span><span>,</span> <span>'string'</span><span>,</span> <span>True</span><span>)</span></code><br><code><span>(</span><span>'single element'</span><span>,)</span></code><br><code><span>()</span></code></td></tr><tr><td><code>dict</code></td><td>可变</td><td><a href="https://zh.wikipedia.org/wiki/%E9%8D%B5-%E5%80%BC%E5%B0%8D">键-值</a><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E5%AF%B9">对</a>的<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a>（常称为字典），即由任意<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88">索引集合</a>来索引的对象的有限<span><span><a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%86%E5%90%88_(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)&amp;action=edit&amp;redlink=1">集合</a></span></span>。不可接受为键的值，是列表或字典，或按值而非对象同一性比较的其他可变类型的值，其<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列</a>值不能保持恒定。</td><td><code><span>{</span><span>'key1'</span><span>:</span> <span>1.0</span><span>,</span> <span>3</span><span>:</span> <span>False</span><span>}</span></code><br><code><span>{}</span></code></td></tr><tr><td><code>set</code></td><td>可变</td><td rowspan="2">无序有限<span><span><a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%86%E5%90%88_(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)&amp;action=edit&amp;redlink=1">集合</a></span></span>，包含唯一性的不可变的对象，它们不能用任何下标来索引。</td><td><code><span>{</span><span>4.0</span><span>,</span> <span>'string'</span><span>,</span> <span>True</span><span>}</span></code><br><code><span>set</span><span>()</span></code></td></tr><tr><td><code>frozenset</code></td><td>不可变</td><td><code><span>frozenset</span><span>([</span><span>4.0</span><span>,</span> <span>'string'</span><span>,</span> <span>True</span><span>])</span></code></td></tr><tr><td><code>types.EllipsisType</code></td><td>不可变</td><td>这个类型有一个单一对象作为值，它通过文字<code>...</code>或内置名字<code><span><span><a href="https://zh.wikipedia.org/w/index.php?title=%E7%9C%81%E7%95%A5%E5%8F%B7_(%E7%BC%96%E7%A8%8B%E8%BF%90%E7%AE%97%E7%AC%A6)&amp;action=edit&amp;redlink=1">Ellipsis</a></span><span><span>（</span><span>英语</span><span>：</span><span><a href="https://en.wikipedia.org/wiki/Ellipsis_(programming_operator)"><span>Ellipsis (programming operator)</span></a></span><span>）</span></span></span></code>来访问，它的<a href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%80%BC">真值</a>为真。它用于<a href="https://zh.wikipedia.org/wiki/NumPy">NumPy</a>多维阵列索引<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-193"><span>[</span>157<span>]</span></a></sup>。</td><td><code><span>...</span></code><br><code><span>Ellipsis</span></code></td></tr><tr><td><code>types.NoneType</code></td><td>不可变</td><td>这个类型有叫做<code>None</code>的一个单一对象<code><a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E6%8C%87%E9%92%88">Null</a></code>作为值<sup><a href="https://zh.wikipedia.org/wiki/#cite_note-194"><span>[</span>158<span>]</span></a></sup>，它被用来指示值的缺席，比如不返回任何东西的函数返回它，它的<a href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%80%BC">真值</a>为假。</td><td><code><span>None</span></code></td></tr><tr><td><code>types.NotImplementedType</code></td><td>不可变</td><td>这个类型有一个单一对象<code>NotImplemented</code>作为值。数值方法和细化比较方法，在它们仍未对提供的运算元实现这个运算之时，返回这个值。它不应该在<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E7%88%BE%E5%80%BC">布尔值</a>上下文中求值。</td><td><code><span>NotImplemented</span></code></td></tr></tbody></table>

除了各种数据类型，Python解释器还内置了很多其他类型，包括可调用类型：用户定义函数、实例方法、生成器函数、协程函数、异步生成器函数、内置函数、内置方法、类、类方法；模块，定制类，类实例，I/O对象（也叫做文件对象），和暴露给用户的一些内部类型：代码对象、框架对象、溯回对象、切片对象、静态方法对象、类方法对象。

Python的算术运算，使用平常的符号`+`、`-`、`*`、`/`和[模除](https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4 "模除")`%`。它还有[下取整](https://zh.wikipedia.org/wiki/%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0 "取整函数")除法算符`//`、[指数](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E5%87%BD%E6%95%B8 "指数函数")算符`**`和[矩阵乘法](https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95 "矩阵乘法")算符`@`[^pep465-130]。二元运算先将两运算元转为共同类型，加法、减法、乘法、下取整除法和指数运算的结果也采用此类型，比如`5**3 == 125`而`9**0.5 == 3.0`。这些算符就像在传统数学中一样运算，具有同样的[优先级规则](https://zh.wikipedia.org/wiki/%E9%81%8B%E7%AE%97%E6%AC%A1%E5%BA%8F "运算次序")，[中缀](https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95 "中缀表示法")算符`+`、`-`，还可以分别表示取原数和取[相反数](https://zh.wikipedia.org/wiki/%E7%9B%B8%E5%8F%8D%E6%95%B0 "相反数")的[一元](https://zh.wikipedia.org/wiki/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97 "一元运算")算符。

被称为“真除法”的`/`的表现，随着版本不同而有着显著变化[^pep0238-195]。自Python 3.0以来，`/`总是产生浮点数结果，包括两个整数相除，比如`5/2 == 2.5`；而在下取整除法`//`中，两个整数相除产生整数，比如`7//3 == 2`而`7.5//3 == 2.0`。

下取整除法`//`的[修约](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E4%BF%AE%E7%BA%A6 "数值修约")是朝向[负无穷](https://zh.wikipedia.org/wiki/%E6%97%A0%E7%A9%B7 "无穷")的。[向下取整](https://zh.wikipedia.org/wiki/%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0 "取整函数")能增加一致性[^autont-62-196]，例如这意味着等式`(a + n)//n == a//n + 1`总是为真。[模除](https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4 "模除")`%`所得出的[余数](https://zh.wikipedia.org/wiki/%E4%BD%99%E6%95%B0 "余数")的符号同于[除数](https://zh.wikipedia.org/wiki/%E9%99%A4%E6%95%B8 "除数")，比如`-4%3 == 2`而`4%-3 == -2`。其它多数编程语言比如[C99](https://zh.wikipedia.org/wiki/C99 "C99")采用[截尾取整](https://zh.wikipedia.org/wiki/%E6%88%AA%E5%B0%BE%E5%87%BD%E6%95%B8 "截尾函数")规则，余数的符号同于[被除数](https://zh.wikipedia.org/wiki/%E8%A2%AB%E9%99%A4%E6%95%B8 "被除数")。模除运算结果余数的定义，确使等式`a == (a//n)*n + a%n`对于`a`和`n`分别为正数或负数的情况都是有效的[^197]。余数可以为负数，显著不同于在数学中的[欧几里得除法](https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E9%99%A4%E6%B3%95 "欧几里得除法")规则下，余数总是非负数的情况。

Python提供了`round()`内置函数，用于把一个浮点数[修约](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E4%BF%AE%E7%BA%A6 "数值修约")成最近的整数[^autont-64-198]，自Python 3.0以来，为了打破平局它采用了[IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754#%E6%B5%AE%E9%BB%9E%E6%95%B8%E7%9A%84%E6%8D%A8%E5%85%A5 "IEEE 754")的[约半成偶](https://zh.wikipedia.org/wiki/%E5%A5%87%E8%BF%9B%E5%81%B6%E8%88%8D "奇进偶舍")规则：`round(1.5)`和`round(2.5)`都产生`2`。

Python允许由比较运算链接起来的布尔表达式，表现得如在数学中常用的一样。比如表达式`a < b < c`，测试`a < b and b < c`[^compare-132]。C语言将它解析为`(a < b) < c`：即首先求值`a < b`，其结果为`0`或`1`，接着把这个结果比较于`c`[^199]。

Python对所有整数运算，使用[任意精度算术](https://zh.wikipedia.org/wiki/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97 "高精度计算")。在`decimal`模块中的`Decimal`类[^200]，提供[十进制浮点数](https://zh.wikipedia.org/w/index.php?title=%E5%8D%81%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0&action=edit&redlink=1 "十进制浮点数（页面不存在）")，具有用户可按需要而更改的缺省28个[十进制](https://zh.wikipedia.org/wiki/%E5%8D%81%E8%BF%9B%E5%88%B6 "十进制")[有效](https://zh.wikipedia.org/wiki/%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97 "有效数字")[数位](https://zh.wikipedia.org/wiki/%E6%95%B0%E4%BD%8D_\(%E6%95%B0%E5%AD%A6\) "数位 (数学)")精度，并有多种修约方式[^201]。在`fractions`模块中的`Fraction`类，提供任意精度的[有理数](https://zh.wikipedia.org/wiki/%E6%9C%89%E7%90%86%E6%95%B0 "有理数")[^202]。第三方库gmpy2[^203]，提供了到[任意精度计算](https://zh.wikipedia.org/wiki/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97 "高精度计算")库[GMP](https://zh.wikipedia.org/wiki/GNU%E5%A4%9A%E9%87%8D%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97%E5%BA%93 "GNU多重精度运算库")/[MPIR](https://zh.wikipedia.org/w/index.php?title=MPIR_\(%E6%95%B0%E5%AD%A6%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "MPIR (数学软件)（页面不存在）")、[MPFR](https://zh.wikipedia.org/w/index.php?title=GNU_MPFR&action=edit&redlink=1 "GNU MPFR（页面不存在）")和MPC的接口。

除了求绝对值函数`abs()`列入内置函数之外，大多数数学函数，处于`math`和`cmath`模块内。前者用于实数运算，而后者用于复数运算。[^204]由于Python有着广泛的数学库，特别是第三方库[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")进一步扩展了固有能力，Python经常被用作科学脚本语言，来处理如数值数据处理和操纵等问题[^205][^206]。

Python拥有一个强大的标准库[^207]。Python标准库包括了如下功能：

- 内置函数
- 内置常量
- 内置类型
- 内置例外
- Python[运行时](https://zh.wikipedia.org/wiki/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F "运行时系统")服务
- 定制Python[解释器](https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8 "解释器")
- [导入](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B "模块化编程")模块
- Python语言服务
- [文本处理](https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86&action=edit&redlink=1 "文本处理（页面不存在）")服务
- [二进制数据](https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE&action=edit&redlink=1 "二进制数据（页面不存在）")服务
- [数据类型](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B "数据类型")
- [数值](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90 "数值分析")和[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6 "数学")模块
- [函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B "函数式编程")模块
- [文件](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6 "计算机文件")和[目录](https://zh.wikipedia.org/wiki/%E7%9B%AE%E5%BD%95_\(%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\) "目录 (文件系统)")访问
- [数据持久化](https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96 "序列化")
- [数据压缩](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9 "数据压缩")和[存档](https://zh.wikipedia.org/wiki/%E6%A1%A3%E6%A1%88 "档案")
- [文件格式](https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E6%A0%BC%E5%BC%8F "文件格式")
- [加密](https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86 "加密")服务
- 通用[操作系统](https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F "操作系统")服务
- [MS Windows](https://zh.wikipedia.org/wiki/MS_Windows "MS Windows")专有服务
- [Unix](https://zh.wikipedia.org/wiki/Unix "Unix")专有服务
- [并发](https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97 "并发计算")[执行](https://zh.wikipedia.org/w/index.php?title=%E6%89%A7%E8%A1%8C_\(%E8%AE%A1%E7%AE%97\)&action=edit&redlink=1 "执行 (计算)（页面不存在）")
- [网络](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97 "网络套接字")和[进程间通信](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1 "进程间通信")
- [互联网数据](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B "互联网媒体类型")[处理](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86 "数据处理")
- [结构式](https://zh.wikipedia.org/w/index.php?title=%E7%BB%93%E6%9E%84%E5%BC%8F%E6%96%87%E6%A1%A3&action=edit&redlink=1 "结构式文档（页面不存在）")[标记](https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80 "置标语言")处理工具
- [互联网协议](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE "互联网协议")及其支持
- [多媒体](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E4%BD%93 "多媒体")服务
- [国际化](https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E5%8C%96 "国际化")
- [程序框架](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6 "软件框架")
- [Tk](https://zh.wikipedia.org/wiki/Tk "Tk")[图形用户界面](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2 "图形用户界面")
- [开发工具](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7 "软件开发工具")
- [调试](https://zh.wikipedia.org/wiki/%E8%B0%83%E8%AF%95 "调试")和[分析](https://zh.wikipedia.org/wiki/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90 "性能分析")
- [软件打包](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F "软件包管理系统")和[发布](https://zh.wikipedia.org/w/index.php?title=%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83&action=edit&redlink=1 "软件发布（页面不存在）")

一个在标准输出设备上输出[Hello World](https://zh.wikipedia.org/wiki/Hello_World "Hello World")的简单编程，这种编程通常作为开始学习编程语言时的第一个编程，可将如下代码录入纯文本文件并随意命名比如`program01.py`，然后执行这个程序`python3 program01.py`：

Python也可以单步解释执行。执行Python解释器进入交互式命令行的环境，你可以在提示符号`>>>`旁输入`print("Hello, world!")`，按Enter键输出结果：

```
>>> print('Hello, world!')
Hello, world!
```

计算正数的[阶乘](https://zh.wikipedia.org/wiki/%E9%98%B6%E4%B9%98 "阶乘")的程序代码：

```
n = int(input('輸入一個數，就會印出其階乘: '))
if n < 0:
    raise ValueError('錯誤，請輸入一個非負整數')
fact = 1
for i in range(2, n + 1):
    fact *= i
print(fact)
```

注意，在Python 3.0及以上版本中，`print`是个函数，需要在要打印的字符串前后加上圆括号；在Python 2.6以下版本中，`print`是一个关键字和命令而不加圆括号。

Python是一门跨平台的脚本语言，Python规定了一个Python语法规则，根据该规则可编写Python[解释器](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8 "解释器")[^208]。Python属于[动态语言](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80 "动态语言")，其官方实现将Python程序编译成中间形式的[字节码](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81 "字节码")[^autont-67-209]，并接着在它的[虚拟机](https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA "虚拟机")上执行[^210]，相较于C/C++和java的等[编译语言](https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80 "编译语言")而言运行速度较慢[^211]。

活跃开发的实现

- [CPython](https://zh.wikipedia.org/wiki/CPython "CPython")：官方的解释器，需要区别于其他解释器的时候才以CPython称呼。CPython默认采用[全局解释器锁](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81 "全局解释器锁")（GIL），以确保在任何时刻只有一个[线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B "线程")执行Python[字节码](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81 "字节码")；一些扩展模块被设计为在进行[计算密集](https://zh.wikipedia.org/wiki/CPU%E5%AF%86%E9%9B%86%E5%9E%8B "CPU密集型")任务时释放GIL，还有在进行[I/O](https://zh.wikipedia.org/wiki/I/O "I/O")时总是释放GIL[^212]。
- [PyPy](https://zh.wikipedia.org/wiki/PyPy "PyPy")：用RPython编写的Python实现，兼容至CPython版本3.10和2.7，它采用了[跟踪JIT](https://zh.wikipedia.org/w/index.php?title=%E8%B7%9F%E8%B8%AA%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91&action=edit&redlink=1 "跟踪即时编译（页面不存在）")，缺省支持stackless模态。
- [MicroPython](https://zh.wikipedia.org/wiki/MicroPython "MicroPython")：为[微控制器](https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8 "微控制器")而优化的Python 3变体，它实现了完整的Python 3.4语法，和补充自版本3.5的`async/await`关键字，和后来版本的一些选定特征；它提供了实现Python标准库模块功能子集的内置模块，和特定于微控制器的一些模块。[CircuitPython](https://zh.wikipedia.org/w/index.php?title=CircuitPython&action=edit&redlink=1 "CircuitPython（页面不存在）")是[Adafruit](https://zh.wikipedia.org/w/index.php?title=Adafruit%E5%B7%A5%E4%B8%9A%E5%85%AC%E5%8F%B8&action=edit&redlink=1 "Adafruit工业公司（页面不存在）")开发的MicroPython分叉。
- Codon：使用了[LLVM](https://zh.wikipedia.org/wiki/LLVM "LLVM")的高性能Python编译器[^213]，它将Python代码编译成本机机器代码，不带有任何[运行时](https://zh.wikipedia.org/wiki/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F "运行时系统")开销并且支持本机[多线程](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B "多线程")，它的语义在[数据类型](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B "数据类型")等方面上与CPython有所不同[^214]，它由[MIT](https://zh.wikipedia.org/wiki/MIT "MIT") [CSAIL](https://zh.wikipedia.org/wiki/MIT%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%E8%88%87%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7%E5%AF%A6%E9%A9%97%E5%AE%A4 "MIT计算机科学与人工智能实验室")的研究人员开发[^215]。
- Pyodide：基于[WebAssembly](https://zh.wikipedia.org/wiki/WebAssembly "WebAssembly")/[Emscripten](https://zh.wikipedia.org/wiki/Emscripten "Emscripten")的用于[浏览器](https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8 "浏览器")和[Node.js](https://zh.wikipedia.org/wiki/Node.js "Node.js")的Python发布[^216]，支持任何在[PyPI](https://zh.wikipedia.org/wiki/PyPI "PyPI")上`wheel`形式的纯Python包，并且已经移植了很多具有C语言扩展的包。
- RustPython：用[Rust](https://zh.wikipedia.org/wiki/Rust "Rust")编写的Python解释器[^rustpython-217]，它可以嵌入到[Rust](https://zh.wikipedia.org/wiki/Rust "Rust")应用程序中从而将Python用作脚本语言，还可以被编译成[WebAssembly](https://zh.wikipedia.org/wiki/WebAssembly "WebAssembly")从而在[浏览器](https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8 "浏览器")中运行Python代码。
- Brython：用[JavaScript](https://zh.wikipedia.org/wiki/JavaScript "JavaScript")编写的在[浏览器](https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8 "浏览器")中运行的Python实现[^218]，具有到[DOM](https://zh.wikipedia.org/wiki/DOM "DOM")元素和事件的接口。

到其他语言的交叉编译器

- [Cython](https://zh.wikipedia.org/wiki/Cython "Cython")：[优化](https://zh.wikipedia.org/wiki/%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E5%99%A8 "优化编译器")[静态](https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B "静态类型")[编译器](https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8 "编译器")，将Python[超集](https://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86 "超集")编译成[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言或[C++](https://zh.wikipedia.org/wiki/C%2B%2B "C++")。Cython补充支持调用C语言函数并且在变量和类特性上声明C语言[类型](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_\(C%E8%AF%AD%E8%A8%80\) "数据类型 (C语言)")，还支持以[OpenMP](https://zh.wikipedia.org/wiki/OpenMP "OpenMP")为后端的本机[多线程](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B "多线程")[并行](https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97 "并行计算")[^219]。
- [Numba](https://zh.wikipedia.org/wiki/Numba "Numba")：使用[LLVM](https://zh.wikipedia.org/wiki/LLVM "LLVM")的[JIT](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")[编译器](https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8 "编译器")，将包括很多[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")函数的聚焦数值计算的Python子集，翻译成快速的机器码，它为在CPU和GPU上并行化Python代码提供了大量选项。
- mypyc：将Python模块编译成C扩展的编译器[^220]，它使用标准的Python类型提示生成快速代码。mypyc是mypy发行的可选依赖，它使用mypy进行[类型检查](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5 "类型检查")和[类型推论](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA "类型推论")[^mypy-189]。
- Pythran：将聚焦于科学计算的Python子集编译成[C++11](https://zh.wikipedia.org/wiki/C%2B%2B11 "C++11")的[提前编译器](https://zh.wikipedia.org/w/index.php?title=%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91&action=edit&redlink=1 "提前编译（页面不存在）")[^221]，它依赖于[Boost](https://zh.wikipedia.org/wiki/Boost_C%2B%2B_Libraries "Boost C++ Libraries")和xsimd库，将标注了接口描述的Python模块编译为本机[共享库](https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%BA%93 "共享库")模块，能利于上[多核](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%A0%B8%E5%BF%83%E8%99%95%E7%90%86%E5%99%A8 "多核心处理器")和[SIMD](https://zh.wikipedia.org/wiki/SIMD "SIMD")指令单元。
- [Nuitka](https://zh.wikipedia.org/w/index.php?title=Nuitka&action=edit&redlink=1 "Nuitka（页面不存在）")：用Python编写的到[C11](https://zh.wikipedia.org/wiki/C11_\(C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86\) "C11 (C语言标准)")（或替补为[C++03](https://zh.wikipedia.org/wiki/C%2B%2B03 "C++03")）的[优化编译器](https://zh.wikipedia.org/wiki/%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E5%99%A8 "优化编译器")[^222]，它依赖于CPython的`libpython`库，能完成嵌入所有模块的程序编译、扩展模块及包编译和独立模态程序发布。
- Transcrypt：用Python编写的Python 3.9到[JavaScript](https://zh.wikipedia.org/wiki/JavaScript "JavaScript")编译器[^223]，用于在[浏览器](https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8 "浏览器")中运行Python代码，它被预先编译为高可读性且高效的[JavaScript](https://zh.wikipedia.org/wiki/JavaScript "JavaScript")代码。
- [MyHDL](https://zh.wikipedia.org/w/index.php?title=MyHDL&action=edit&redlink=1 "MyHDL（页面不存在）")：将Python编译成[Verilog](https://zh.wikipedia.org/wiki/Verilog "Verilog")或[VHDL](https://zh.wikipedia.org/wiki/VHDL "VHDL")[^224]。

其他实现举例：[Jython](https://zh.wikipedia.org/wiki/Jython "Jython")，它是用[Java](https://zh.wikipedia.org/wiki/Java "Java")实现的Python 2.7。[IronPython](https://zh.wikipedia.org/wiki/IronPython "IronPython")，它是建造在[DLR](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%97%B6 "动态语言运行时")之上的Python 2.7和Python 3.4实现。[Stackless Python](https://zh.wikipedia.org/wiki/Stackless_Python "Stackless Python")，它是实现[微线程](https://zh.wikipedia.org/w/index.php?title=%E5%BE%AE%E7%BA%BF%E7%A8%8B&action=edit&redlink=1 "微线程（页面不存在）")的CPython 3.8分叉。Pyston，它是具有[JIT](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")等性能优化的CPython 3.8.12的分叉[^pyston-225]。Pyjion，将Python代码编译成本机[CIL](https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80 "通用中间语言")的CPython 3.10的[JIT](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")扩展[^226]。Cinder，它是[Meta孵化器](https://zh.wikipedia.org/wiki/Meta_Platforms "Meta Platforms")发布的具有包括[JIT](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")等很多优化的CPython 3.10分叉[^meta-227]。

很多并非集成开发环境软件的[文本编辑器](https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8 "文本编辑器")，也对Python有不同程度的支持，并且加上专门为Python设计的编辑器[插件](https://zh.wikipedia.org/wiki/%E6%8F%92%E4%BB%B6 "插件")也会有很高的可用性。

- [Visual Studio Code](https://zh.wikipedia.org/wiki/Visual_Studio_Code "Visual Studio Code")
- [Atom](https://zh.wikipedia.org/wiki/Atom_\(%E6%96%87%E5%AD%97%E7%B7%A8%E8%BC%AF%E5%99%A8\) "Atom (文本编辑器)")
- [Eclipse](https://zh.wikipedia.org/wiki/Eclipse "Eclipse")
- [emacs](https://zh.wikipedia.org/wiki/Emacs "Emacs")
- [SlickEdit](https://zh.wikipedia.org/wiki/SlickEdit "SlickEdit")
- [TextMate](https://zh.wikipedia.org/wiki/TextMate "TextMate")
- [Vim](https://zh.wikipedia.org/wiki/Vim "Vim")
- [Sublime Text](https://zh.wikipedia.org/wiki/Sublime_Text "Sublime Text")
- [EditPlus](https://zh.wikipedia.org/wiki/EditPlus "EditPlus")
- [UltraEdit](https://zh.wikipedia.org/wiki/UltraEdit "UltraEdit")
- [PSPad](https://zh.wikipedia.org/wiki/PSPad "PSPad")
- [Notepad++](https://zh.wikipedia.org/wiki/Notepad%2B%2B "Notepad++")

适用于Python的[集成开发环境](https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83 "集成开发环境")（IDE）软件，除了标准二进制发布包所附的IDLE之外，还有许多其他选择。其中有些软件设计有语法着色、语法检查、运行[调试](https://zh.wikipedia.org/wiki/%E8%B0%83%E8%AF%95 "调试")、自动补全、智能感知等便利功能。由于Python的[跨平台](https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0 "跨平台")出身，这些软件往往也具备各种操作系统的版本或一定的移植性。

- [IDLE](https://zh.wikipedia.org/wiki/IDLE_\(Python\) "IDLE (Python)")：Python“标准”IDE，一般随Python而安装，支持较少的编辑功能，调试功能也比较弱。
- [Eric](https://zh.wikipedia.org/wiki/Eric_Python_IDE "Eric Python IDE")：基于[PyQt](https://zh.wikipedia.org/wiki/PyQt "PyQt")的自由的IDE，支持自动补全、智能感知、自动语法检查、工程管理、svn/mercurial集成、自动单元测试等功能，具有可扩展的插件系统，通过可选插件支持[Git](https://zh.wikipedia.org/wiki/Git "Git")集成。调试功能与Visual Studio和Eclipse类似。
- [Spyder](https://zh.wikipedia.org/wiki/Spyder "Spyder")：开源的跨平台科学计算IDE。
- [PyScripter](https://zh.wikipedia.org/w/index.php?title=PyScripter&action=edit&redlink=1 "PyScripter（页面不存在）")：功能较全的开源IDE，使用Delphi开发。
- [PyCharm](https://zh.wikipedia.org/wiki/PyCharm "PyCharm")：由[JetBrains](https://zh.wikipedia.org/wiki/JetBrains "JetBrains")公司出品，具备一般IDE的功能，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等等，另外，它还提供了一些功能用于Django开发，同时支持[Google App Engine](https://zh.wikipedia.org/wiki/Google_App_Engine "Google App Engine")，还支持IronPython。它是商业软件，但也具有社区版和教育版。
- [Thonny](https://zh.wikipedia.org/w/index.php?title=Thonny&action=edit&redlink=1 "Thonny（页面不存在）")：适用于编程初学者的IDE。
- [Wing IDE](https://zh.wikipedia.org/w/index.php?title=Wing_IDE&action=edit&redlink=1 "Wing IDE（页面不存在）")：商业软件，有免费的功能有限的Wing 101。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Python_Powered.png/340px-Python_Powered.png)

Python Powered

Python社群提供了大量的功能覆盖众多领域的第三方模块，其使用方式与标准库类似。第三方模块可以使用Python/Cython或者[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")语言编写。软件工具[SWIG](https://zh.wikipedia.org/wiki/SWIG "SWIG")和[SIP](https://zh.wikipedia.org/w/index.php?title=SIP_\(%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "SIP (软件)（页面不存在）")，通过定义接口文件或规定文件的方式，可以将[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")/[C++](https://zh.wikipedia.org/wiki/C%2B%2B "C++")编写的程序库包装为Python模块。Python解释器本身也可以被集成到其它需要脚本语言的编程内。

[Python包索引](https://zh.wikipedia.org/wiki/PyPI "PyPI")是公开的软件包在线仓库。[pip](https://zh.wikipedia.org/wiki/Pip_\(%E8%BB%9F%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1\) "Pip (软件包管理系统)")是官网推荐的以安全方式安装Python应用及其依赖软件包的最流行工具[^228]。要安装在整个操作系统范围内共享的Python包，现在需要通过操作系统的[软件包管理系统](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F "软件包管理系统")。要将特定于应用的依赖包隔离于共享的Python安装，可以使用标准库的venv[^229]或第三方工具virtualenv[^230]创建虚拟环境；第三方工具pipenv，能自动为用户项目建立和管理虚拟环境，并在安装/卸装软件包的时候，向此项目的Pipfile文件增加/移除这个软件包[^231]。

Python定义了[WSGI](https://zh.wikipedia.org/wiki/WSGI "WSGI")标准应用接口，来协调[HTTP](https://zh.wikipedia.org/wiki/HTTP "HTTP")服务器与基于Python的Web编程之间的沟通。比如，通过[mod\_wsgi](https://zh.wikipedia.org/w/index.php?title=Mod_wsgi&action=edit&redlink=1 "Mod wsgi（页面不存在）")模块，[Apache](https://zh.wikipedia.org/wiki/Apache "Apache")可以运行用Python编写的Web编程。[Zope](https://zh.wikipedia.org/wiki/Zope "Zope")是著名的用Python编写的开源的Web[应用服务器](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8 "应用服务器")。[Tornado](https://zh.wikipedia.org/wiki/Tornado "Tornado")是用Python语言写成的非阻塞式web服务器，也是轻量级的Web框架。

Python对于各种网络协议的支持很完善，因此适用于编写服务器软件、网络爬虫等Web开发。用Python编写的一些Web框架，有助于轻松地开发和管理复杂的Web编程。著名的第三方[Web框架](https://zh.wikipedia.org/wiki/Web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6 "Web应用框架")和函数库：

- [Django](https://zh.wikipedia.org/wiki/Django "Django")：MTV架构[^232]的Web开发框架，注重组件的重用性和“可插拔性”、[快速开发](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%87%89%E7%94%A8%E9%96%8B%E7%99%BC "快速应用开发")和[DRY法则](https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1 "一次且仅一次")。
- [Pyramid](https://zh.wikipedia.org/wiki/Pylons#Pyramid "Pylons")：极简主义的Web框架，不预定[持久化](https://zh.wikipedia.org/wiki/%E6%8C%81%E4%B9%85%E5%8C%96 "持久化")方式。
- [Flask](https://zh.wikipedia.org/wiki/Flask "Flask")：微Web框架，不要求特定的工具或库。
- PyScript：创建在浏览器内的Python应用的框架[^233]，这些应用能使用[HTML](https://zh.wikipedia.org/wiki/HTML "HTML")界面和已编译成[WebAssembly](https://zh.wikipedia.org/wiki/WebAssembly "WebAssembly")的Pyodide或[MicroPython](https://zh.wikipedia.org/wiki/MicroPython "MicroPython")，以及当代Web技术。
- [Twisted](https://zh.wikipedia.org/wiki/Twisted "Twisted")：[事件驱动](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95 "事件驱动")的网络编程框架。它支持多数标准的网络协议（包含客户端和服务器），并且提供了多种工具，适用于编写高性能的服务器软件。
- [Requests](https://zh.wikipedia.org/wiki/Requests "Requests")：适合于常人使用的HTTP库，封装了许多繁琐的HTTP功能，极大地简化了HTTP请求所需要的代码量。
- [Beautiful Soup](https://zh.wikipedia.org/wiki/Beautiful_Soup "Beautiful Soup")：用来解析HTML/XML的一个简单易用Python包。
- uvloop：是对内置`asyncio`[事件循环](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF "事件循环")的快速的、直截了当的替代者[^234]，它用[Cython](https://zh.wikipedia.org/wiki/Cython "Cython")实现并在底层使用了[libuv](https://zh.wikipedia.org/wiki/Libuv "Libuv")。
- aiohttp：基于`asyncio`的HTTP客户端和服务器二者[^235]。

Python本身包含了[Tkinter](https://zh.wikipedia.org/wiki/Tkinter "Tkinter")库，它是Python的业界标准[GUI](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2 "图形用户界面")并被集成进入了[IDLE](https://zh.wikipedia.org/wiki/IDLE_\(Python\) "IDLE (Python)")。Tkinter基于了[Tcl](https://zh.wikipedia.org/wiki/Tcl "Tcl")命令工具，能够支持简单的[GUI](https://zh.wikipedia.org/wiki/GUI "GUI")开发。但是为了让所开发的软件运行速度更快，并与用户的桌面环境更契合，人们一般会选择采用第三方GUI库或框架。著名的第三方GUI库：

- [PyQt](https://zh.wikipedia.org/wiki/PyQt "PyQt")：[Qt](https://zh.wikipedia.org/wiki/Qt "Qt")的Python绑定库，由Riverbank Computing公司自从1998年发行，采用GPL许可证或商业许可证。
- [PySide](https://zh.wikipedia.org/wiki/PySide "PySide")：[Qt](https://zh.wikipedia.org/wiki/Qt "Qt")的Python绑定库，由[Qt公司](https://zh.wikipedia.org/wiki/Qt%E5%85%AC%E5%8F%B8 "Qt公司")自从2009年发行，采用LGPL许可证。
- PyGObject：替代了[PyGTK](https://zh.wikipedia.org/wiki/PyGTK "PyGTK")，它是为Python程序访问基于[GObject](https://zh.wikipedia.org/wiki/GObject "GObject")的库而提供的[包装库](https://zh.wikipedia.org/wiki/%E5%8C%85%E8%A3%85%E5%BA%93 "包装库")[^236]，GObject是[GTK](https://zh.wikipedia.org/wiki/GTK "GTK")、[GIO](https://zh.wikipedia.org/w/index.php?title=GIO_\(%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "GIO (软件)（页面不存在）")和[GStreamer](https://zh.wikipedia.org/wiki/GStreamer "GStreamer")等库使用的对象系统。
- [Kivy](https://zh.wikipedia.org/wiki/Kivy "Kivy")：用于开发多点触控应用软件的开源Python库，采用了[自然用户界面](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2 "自然用户界面")（NUI）。
- [WxPython](https://zh.wikipedia.org/wiki/WxPython "WxPython")：GUI编程框架[wxWidgets](https://zh.wikipedia.org/wiki/WxWidgets "WxWidgets")的Python[包装库](https://zh.wikipedia.org/wiki/%E5%8C%85%E8%A3%85%E5%BA%93 "包装库")，它与[MFC](https://zh.wikipedia.org/wiki/MFC_\(%E5%BE%AE%E8%BB%9F\) "MFC (微软)")的架构相似。
- PySimpleGUI：将Tkinter、Qt、WxPython和Remi[^237]的GUI框架变换成简单的接口[^238]。
- Gooey：将几乎所有Python 3控制台程序用一行代码转变成GUI应用[^239]。
- Dear PyGui：快速而强力的具有极小依赖性的GUI工具箱[^240]。
- pywebview：轻量级跨平台的对[WebView](https://zh.wikipedia.org/w/index.php?title=WebView&action=edit&redlink=1 "WebView（页面不存在）")构件的包装器，允许在其本地GUI窗口中显示HTML内容[^241]。

重要的[数据科学](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6 "数据科学")用第三方软件库有：

- [NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")：Python的基础性的[科学计算](https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97 "科学计算")软件库，它提供了强力的多维[阵列](https://zh.wikipedia.org/wiki/%E9%98%B5%E5%88%97%E7%BC%96%E7%A8%8B "阵列编程")对象，广播式阵列运算[^242]，集成[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")/[C++](https://zh.wikipedia.org/wiki/C%2B%2B "C++")和[Fortran](https://zh.wikipedia.org/wiki/Fortran "Fortran")代码的工具，较为有用的[线性代数](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0 "线性代数")、[傅里叶变换](https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2 "傅里叶变换")和[随机数](https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0 "随机数")功能。
- [SciPy](https://zh.wikipedia.org/wiki/SciPy "SciPy")：用于[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6 "数学")、[科学](https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6 "科学")和[工程](https://zh.wikipedia.org/wiki/%E5%B7%A5%E7%A8%8B%E5%AD%A6 "工程学")的Python软件库，它以[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")的多维[阵列](https://zh.wikipedia.org/wiki/%E9%98%B5%E5%88%97%E7%BC%96%E7%A8%8B "阵列编程")作为基本数据结构，所包含的模块针对了：[统计](https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%AD%A6 "统计学")、[最优化](https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BC%98%E5%8C%96 "最优化")、[数值积分](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86 "数值积分")、[常微分方程求解](https://zh.wikipedia.org/wiki/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B "常微分方程")、[插值](https://zh.wikipedia.org/wiki/%E6%8F%92%E5%80%BC "插值")、[线性代数](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0 "线性代数")、[傅里叶变换](https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2 "傅里叶变换")、[信号处理](https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86 "信号处理")、[图像处理](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86 "图像处理")等。
- [CuPy](https://zh.wikipedia.org/w/index.php?title=CuPy&action=edit&redlink=1 "CuPy（页面不存在）")：NumPy/SciPy兼容的[GPU](https://zh.wikipedia.org/wiki/GPU "GPU")加速的[阵列](https://zh.wikipedia.org/wiki/%E9%98%B5%E5%88%97%E7%BC%96%E7%A8%8B "阵列编程")库[^243]，它可在[NVIDIA](https://zh.wikipedia.org/wiki/NVIDIA "NVIDIA") [CUDA](https://zh.wikipedia.org/wiki/CUDA "CUDA")或[AMD](https://zh.wikipedia.org/wiki/AMD "AMD") [ROCm](https://zh.wikipedia.org/wiki/ROCm "ROCm")平台上充当其直截了当的替代者，来运行现存的NumPy/SciPy代码。
- [matplotlib](https://zh.wikipedia.org/wiki/Matplotlib "Matplotlib")：基于[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")的综合性[绘图](https://zh.wikipedia.org/w/index.php?title=%E7%BB%98%E5%9B%BE&action=edit&redlink=1 "绘图（页面不存在）")[库](https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB "函数库")，用于创建静态的、动画的和交互式的[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")。
- [pandas](https://zh.wikipedia.org/wiki/Pandas "Pandas")：用于[数据分析](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90 "数据分析")和[数据操纵](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86 "数据处理")的软件库，它建造在[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")基础上，提供了加标签数据结构“数据帧”[^244]，和统计函数等。它的缺省绘图后端是[matplotlib](https://zh.wikipedia.org/wiki/Matplotlib "Matplotlib")，还可以扩展上第三方[绘图](https://zh.wikipedia.org/w/index.php?title=%E7%BB%98%E5%9B%BE&action=edit&redlink=1 "绘图（页面不存在）")后端[^245]。
- [Dask](https://zh.wikipedia.org/w/index.php?title=Dask_\(%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "Dask (软件)（页面不存在）")：伸缩范围从[笔记本电脑](https://zh.wikipedia.org/wiki/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91 "笔记本电脑")至[计算机集群](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4 "计算机集群")的[并行计算](https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97 "并行计算")库[^246]，它提供的用户接口镜像了PyData生态系统中pandas、scikit-learn和NumPy的API。

主要的[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")软件库及[仪表板](https://zh.wikipedia.org/wiki/%E5%84%80%E8%A1%A8%E6%9D%BF_\(%E5%95%86%E5%8B%99\) "仪表板 (商务)")框架有[^247]：

- VisPy：高性能交互式2D/3D[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")库[^248]，它通过多种后端[OpenGL](https://zh.wikipedia.org/wiki/OpenGL "OpenGL")库之一来显示非常大的[数据集](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%9B%86 "数据集")，并提供叫做gloo的受用[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")的Python风格[OpenGL ES](https://zh.wikipedia.org/wiki/OpenGL_ES "OpenGL ES") 2.0接口。
- glumpy：用于科学[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")的快速、可伸缩的Python库[^249]，它基于了[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")和[OpenGL](https://zh.wikipedia.org/wiki/OpenGL "OpenGL")绑定库PyOpenGL。
- seaborn：基于[matplotlib](https://zh.wikipedia.org/wiki/Matplotlib "Matplotlib")的[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")库[^250]，它提供了绘制[统计图形](https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%9B%BE%E5%BD%A2 "统计图形")的高层接口。
- Vega-Altair：建造在[Vega-Lite](https://zh.wikipedia.org/wiki/Vega%E5%92%8CVega-Lite%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AF%AD%E6%B3%95 "Vega和Vega-Lite可视化语法") [JSON](https://zh.wikipedia.org/wiki/JSON "JSON")规定之上的声明式统计[可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")库[^251]。
- Bokeh：针对现代[Web](https://zh.wikipedia.org/wiki/Web "Web")[浏览器](https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8 "浏览器")的交互式[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")库[^252]，它在大型或[流式](https://zh.wikipedia.org/w/index.php?title=%E6%B5%81%E6%95%B0%E6%8D%AE&action=edit&redlink=1 "流数据（页面不存在）")的[数据集](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%9B%86 "数据集")上提供高效的交互性。
- plotly：交互式开源的基于浏览器的[图形绘制](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2 "计算机图形")库[^253]，它是建造在plotly.js之上的声明式[图表](https://zh.wikipedia.org/wiki/%E7%B5%B1%E8%A8%88%E5%9C%96%E8%A1%A8 "统计图表")库。
- Dash：数据应用和[仪表板](https://zh.wikipedia.org/wiki/%E5%84%80%E8%A1%A8%E6%9D%BF_\(%E5%95%86%E5%8B%99\) "仪表板 (商务)")框架，它可将现代[用户界面](https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2 "用户界面")元素如[下拉选单](https://zh.wikipedia.org/wiki/%E4%B8%8B%E6%8B%89%E5%BC%8F%E9%80%89%E5%8D%95 "下拉式选单")、[滑动条](https://zh.wikipedia.org/w/index.php?title=%E6%BB%91%E5%8A%A8%E6%9D%A1&action=edit&redlink=1 "滑动条（页面不存在）")和[图形](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2 "计算机图形")，直接链接至分析型Python代码[^254]，它由[Plotly](https://zh.wikipedia.org/w/index.php?title=Plotly%E5%85%AC%E5%8F%B8&action=edit&redlink=1 "Plotly公司（页面不存在）")公司出品，基于了[React](https://zh.wikipedia.org/wiki/React "React")、[Flask](https://zh.wikipedia.org/wiki/Flask "Flask")和plotly.js[^255]。
- Panel：[数据探索](https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2&action=edit&redlink=1 "数据探索（页面不存在）")和Web应用框架，它能无缝的集成于PyData生态系统，提供交互式数据表格和可视化等功能[^256]，它是HoloViz生态系统的成员[^257]，这个工具组还包括了：hvPlot、HoloViews、GeoViews、Datashader、Lumen、Param和Colorcet。
- Streamlit：迅速将Python脚本转变为可共享Web应用的框架[^258]。
- Voilà：将[Jupyter Notebook](https://zh.wikipedia.org/wiki/Jupyter#Jupyter_Notebook "Jupyter")转变为独立的Web应用的框架[^259]。

基础性的[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")软件库及框架有：

- [scikit-learn](https://zh.wikipedia.org/wiki/Scikit-learn "Scikit-learn")：[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")软件库，它提供的功能包括：[监督学习](https://zh.wikipedia.org/wiki/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0 "监督学习")中的[分类](https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%88%86%E7%B1%BB "统计分类")和[回归](https://zh.wikipedia.org/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90 "回归分析")，[无监督学习](https://zh.wikipedia.org/wiki/%E7%84%A1%E7%9B%A3%E7%9D%A3%E5%AD%B8%E7%BF%92 "无监督学习")中的[聚类](https://zh.wikipedia.org/wiki/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90 "聚类分析")和[降维](https://zh.wikipedia.org/wiki/%E9%99%8D%E7%BB%B4 "降维")，还有[模型选择](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9 "模型选择")和[数据预处理](https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86&action=edit&redlink=1 "数据预处理（页面不存在）")。它基于了[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")、[SciPy](https://zh.wikipedia.org/wiki/SciPy "SciPy")、轻量级[管道](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_\(%E8%BD%AF%E4%BB%B6\) "管道 (软件)")库Joblib[^260]和[线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0 "线程池")控制库threadpoolctl[^261]，其绘图功能依赖于[matplotlib](https://zh.wikipedia.org/wiki/Matplotlib "Matplotlib")，还用到了[scikit-image](https://zh.wikipedia.org/w/index.php?title=Scikit-image&action=edit&redlink=1 "Scikit-image（页面不存在）")、seaborn和plotly。
- [PyMC](https://zh.wikipedia.org/wiki/PyMC "PyMC")：基于从[Theano](https://zh.wikipedia.org/wiki/Theano "Theano")分叉出的PyTensor的[概率编程](https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B "概率编程")库，它用于建立[贝叶斯统计](https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1 "贝叶斯统计")[模型](https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B "概率模型")，并使用[马尔可夫链蒙特卡洛](https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B "马尔可夫链蒙特卡洛")（MCMC）方法进行模型[拟合](https://zh.wikipedia.org/wiki/%E6%8B%9F%E5%90%88 "拟合")。
- [TensorFlow](https://zh.wikipedia.org/wiki/TensorFlow "TensorFlow")：[Google](https://zh.wikipedia.org/wiki/Google "Google")开发的“端到端”[开源](https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90 "开源")[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")平台，它提供了Python API[^262]，其中实现了[Keras](https://zh.wikipedia.org/wiki/Keras "Keras") API[^263]。[Keras](https://zh.wikipedia.org/wiki/Keras "Keras")现在是在TensorFlow 2上建立的[深度学习](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0 "深度学习")高层API。
- [PyTorch](https://zh.wikipedia.org/wiki/PyTorch "PyTorch")：[Meta](https://zh.wikipedia.org/wiki/Meta_Platforms "Meta Platforms")在[Torch](https://zh.wikipedia.org/w/index.php?title=Torch_\(%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\)&action=edit&redlink=1 "Torch (机器学习)（页面不存在）")基础上开发的[开源](https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90 "开源")的Python软件包，提供了具有强大的[GPU](https://zh.wikipedia.org/wiki/GPU "GPU")加速的[张量](https://zh.wikipedia.org/wiki/%E5%BC%A0%E9%87%8F "张量")计算，和建立在基于tape的[自动微分](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86 "自动微分")系统上的[深度神经网络](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C "深度神经网络")。
- [JAX](https://zh.wikipedia.org/wiki/Google_JAX "Google JAX")：[Google](https://zh.wikipedia.org/wiki/Google "Google")开发的[开源](https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90 "开源")[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")框架，其核心是可任意组合的对数值[纯函数](https://zh.wikipedia.org/wiki/%E7%BA%AF%E5%87%BD%E6%95%B0 "纯函数")的变换[^264]，它结合了修改版本的针对[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")的[自动微分](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86 "自动微分")库Autograd[^265]，和[TensorFlow](https://zh.wikipedia.org/wiki/TensorFlow "TensorFlow")中的加速线性代数库XLA[^266]，它使用XLA来在[GPU](https://zh.wikipedia.org/wiki/GPU "GPU")和[TPU](https://zh.wikipedia.org/wiki/TPU "TPU")上编译和运行[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")程序。

- pegen：Python的[PEG](https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95 "解析表达文法")解析器生成器[^267]。
- PeachPy：采用高层Python的可移植高效[x86-64](https://zh.wikipedia.org/wiki/X86-64 "X86-64")[汇编代码](https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81 "汇编代码")生成器[^268]。
- llvmlite：轻量级的[LLVM](https://zh.wikipedia.org/wiki/LLVM "LLVM")的Python绑定，用于编写[即时编译器](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")[^269]。
- [SymPy](https://zh.wikipedia.org/wiki/SymPy "SymPy")：支持数学符号运算的软件库，用于提供[计算机代数系统](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F "计算机代数系统")。
- [SimPy](https://zh.wikipedia.org/wiki/SimPy "SimPy")：基于由Python[生成器函数](https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\) "生成器 (计算机编程)")定义的进程的[离散事件模拟](https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F "离散事件模拟")框架[^270]。
- ModernGL：不同于PyOpenGL[^271]，ModernGL是在[OpenGL](https://zh.wikipedia.org/wiki/OpenGL "OpenGL") 3.3+核心上的Python包装器[^272]，它简化了简单图形应用如科学模拟、游戏和用户界面的创建。
- PyCUDA：不同于[Nvidia](https://zh.wikipedia.org/wiki/Nvidia "Nvidia")的cuda-python[^273]，PyCUDA提供对[CUDA](https://zh.wikipedia.org/wiki/CUDA "CUDA") API的Python风格访问[^274]。
- PyOpenCL：PyOpenCL提供对[OpenCL](https://zh.wikipedia.org/wiki/OpenCL "OpenCL") API的Python风格访问[^275]，例如[光滑粒子流体动力学](https://zh.wikipedia.org/wiki/%E5%85%89%E6%BB%91%E7%B2%92%E5%AD%90%E6%B5%81%E4%BD%93%E5%8A%A8%E5%8A%9B%E5%AD%A6 "光滑粒子流体动力学")框架PySPH的性能关键部分用Cython和PyOpenCL实现[^276]。
- Kompute：基于[Vulkan](https://zh.wikipedia.org/wiki/Vulkan "Vulkan")的通用计算框架[^277]，它是高速的、支持移动设备、异步的并且针对高级GPU数据处理用例做了优化。
- Taichi Lang：采用同Python几乎一样语法的指令式[并行](https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97 "并行计算")编程语言[^278]，它嵌入在Python之中并使用[即时编译器](https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF "即时编译")框架如[LLVM](https://zh.wikipedia.org/wiki/LLVM "LLVM")，将计算密集的Python代码转变成本机GPU或CPU指令。
- [SQLAlchemy](https://zh.wikipedia.org/wiki/SQLAlchemy "SQLAlchemy")：Python的[SQL](https://zh.wikipedia.org/wiki/SQL "SQL")工具包和采用[数据映射器模式](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%99%A8%E6%A8%A1%E5%BC%8F "数据映射器模式")的[对象关系映射器](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%E5%99%A8 "对象关系映射器")（ORM）。
- Graphene：[GraphQL](https://zh.wikipedia.org/wiki/GraphQL "GraphQL")框架[^279]，支持各种数据源如[SQLAlchemy](https://zh.wikipedia.org/wiki/SQLAlchemy "SQLAlchemy")、[Mongo](https://zh.wikipedia.org/wiki/MongoDB "MongoDB")、[Django](https://zh.wikipedia.org/wiki/Django "Django")和定制Python对象等。GQL是常用来与之配合的GraphQL客户端Python库[^280]。
- [Pillow](https://zh.wikipedia.org/w/index.php?title=Python%E5%9B%BE%E5%83%8F%E5%BA%93&action=edit&redlink=1 "Python图像库（页面不存在）")：是基于Python的[图像处理](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86 "图像处理")软件库[^281]，它支持广泛的图形文件格式，分叉于已终止的PIL。
- pypdf：能够分割、合并、修剪和转变[PDF](https://zh.wikipedia.org/wiki/PDF "PDF")文件的Python软件库[^282]。
- PyFilesystem2：Python的文件系统抽象层[^283]，将在归档、内存和云端存储等之中的文件和目录，像在本地驱动器中一样容易的处置。
- Fabric：经由[SSH](https://zh.wikipedia.org/wiki/Secure_Shell "Secure Shell")远程执行shell命令的高层库[^284]，它产生有用的Python对象作为回馈。
- Prefect：现代[工作流程](https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B "工作流程")编排框架[^285]，它易于建造、调度和监控健壮的数据流水线。
- [pygame](https://zh.wikipedia.org/wiki/Pygame "Pygame")：开发[视频游戏](https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91%E6%B8%B8%E6%88%8F "视频游戏")的Python软件库，基于了[SDL](https://zh.wikipedia.org/wiki/SDL "SDL")软件库[^286]。视觉小说引擎[Ren'Py](https://zh.wikipedia.org/wiki/Ren%27Py "Ren'Py")建造在pygame之上。
- [pyglet](https://zh.wikipedia.org/wiki/Pyglet "Pyglet")：Python编写的面向对象的游戏和[多媒体](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E4%BD%93 "多媒体")库，利用了[FFmpeg](https://zh.wikipedia.org/wiki/FFmpeg "FFmpeg")软件库并需要OpenGL 3.3+。2D[街机](https://zh.wikipedia.org/wiki/%E8%A1%97%E6%9C%BA "街机")游戏开发库Arcade基于了pyglet[^287]，它还利用了建造在[2D](https://zh.wikipedia.org/wiki/%E4%BA%8C%E7%BB%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2 "二维计算机图形")[物理引擎](https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E "物理引擎")[Chipmunk](https://zh.wikipedia.org/w/index.php?title=Chipmunk_\(%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "Chipmunk (软件)（页面不存在）")之上的Pymunk[^288]。
- [Panda3D](https://zh.wikipedia.org/w/index.php?title=Panda3D&action=edit&redlink=1 "Panda3D（页面不存在）")：[开源](https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90 "开源")[游戏引擎](https://zh.wikipedia.org/wiki/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E "游戏引擎")，包括了图形、音频、I/O、[碰撞侦测](https://zh.wikipedia.org/wiki/%E7%A2%B0%E6%92%9E%E5%81%B5%E6%B8%AC "碰撞侦测")和其他与[3D](https://zh.wikipedia.org/wiki/%E4%B8%89%E7%BB%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2 "三维计算机图形")游戏有关的功能，使用Python作为游戏开发语言[^289]。
- pythonnet：可以近乎无缝的集成[.NET](https://zh.wikipedia.org/wiki/.NET ".NET")[通用语言运行库](https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E8%AA%9E%E8%A8%80%E9%81%8B%E8%A1%8C%E5%BA%AB "通用语言运行库")（CLR）的程序包[^290]。
- PyInstaller：将Python应用和它的依赖项捆绑成一个单一的包[^291]，从而不需要安装Python解释器或任何模块就可以运行应用。

在很多操作系统里，Python是标准的系统组件，它被列入[Linux标准规范](https://zh.wikipedia.org/wiki/Linux%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83 "Linux标准规范")之中[^292]。大多数[Linux发行版](https://zh.wikipedia.org/wiki/Linux%E7%99%BC%E8%A1%8C%E7%89%88 "Linux发行版")和[macOS](https://zh.wikipedia.org/wiki/MacOS "MacOS")都集成了Python，可以在[终端模拟器](https://zh.wikipedia.org/wiki/%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8 "终端模拟器")或[虚拟控制台](https://zh.wikipedia.org/w/index.php?title=%E8%99%9A%E6%8B%9F%E6%8E%A7%E5%88%B6%E5%8F%B0&action=edit&redlink=1 "虚拟控制台（页面不存在）")下直接执行Python。第三方工具pipx，可以将Python应用安装于隔离的环境中并在其中运行它[^293]。

虽然Python可被粗略地分类为[脚本语言](https://zh.wikipedia.org/wiki/%E8%85%B3%E6%9C%AC%E8%AA%9E%E8%A8%80 "脚本语言")，Python的支持者较喜欢称它为一种高阶[动态语言](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80 "动态语言")，常像“胶水”一样被用来连接[软件组件](https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B "基于组件的软件工程")，已经显著的区别于[Unix shell](https://zh.wikipedia.org/wiki/Unix_shell "Unix shell")、[Windows](https://zh.wikipedia.org/wiki/Windows "Windows") [PowerShell](https://zh.wikipedia.org/wiki/PowerShell "PowerShell")这样的语言。基于Python的xonsh，是跨平台的、青睐Unix的[shell](https://zh.wikipedia.org/wiki/%E6%AE%BC%E5%B1%A4 "壳层")[语言](https://zh.wikipedia.org/wiki/%E5%A4%96%E5%A3%B3%E8%84%9A%E6%9C%AC "外壳脚本")和[命令行界面](https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2 "命令行界面")[^294]。

一些Linux发行版，使用Python语言编写安装器，比如[Ubuntu](https://zh.wikipedia.org/wiki/Ubuntu "Ubuntu")的[Ubiquity](https://zh.wikipedia.org/wiki/Ubiquity_\(%E8%BD%AF%E4%BB%B6\) "Ubiquity (软件)")和[Fedora](https://zh.wikipedia.org/wiki/Fedora_\(%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1\) "Fedora (操作系统)")的[Anaconda](https://zh.wikipedia.org/wiki/Anaconda "Anaconda")；或使用它编写[软件包管理系统](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F "软件包管理系统")，比如[Gentoo](https://zh.wikipedia.org/wiki/Gentoo_Linux "Gentoo Linux")的[Portage](https://zh.wikipedia.org/wiki/Portage "Portage")。如下著名应用使用Python编写或将它作为嵌入式脚本：

- [IPython](https://zh.wikipedia.org/wiki/IPython "IPython")：以多种编程语言进行交互式计算的[命令shell](https://zh.wikipedia.org/wiki/%E6%AE%BC%E5%B1%A4 "壳层")和[Jupyter](https://zh.wikipedia.org/wiki/Jupyter "Jupyter")的内核，最初为Python开发，它提供了[内省](https://zh.wikipedia.org/wiki/%E5%86%85%E7%9C%81_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\) "内省 (计算机科学)")、[富媒体](https://zh.wikipedia.org/wiki/%E4%BA%92%E5%8B%95%E5%BC%8F%E5%A4%9A%E5%AA%92%E9%AB%94 "交互式多媒体")、shell语法、[tab补全](https://zh.wikipedia.org/w/index.php?title=%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A1%A5%E5%85%A8&action=edit&redlink=1 "命令行补全（页面不存在）")和历史。
- [Conda](https://zh.wikipedia.org/wiki/Conda "Conda")：跨平台的、语言无关的二进制[包管理器](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F "软件包管理系统")，它被[Anaconda发行](https://zh.wikipedia.org/wiki/Anaconda_\(Python%E5%8F%91%E8%A1%8C%E7%89%88\) "Anaconda (Python发行版)")采用。
- [SCons](https://zh.wikipedia.org/wiki/SCons "SCons")：软件建造工具，它可代替make构建编译程序。
- [Gunicorn](https://zh.wikipedia.org/w/index.php?title=Gunicorn&action=edit&redlink=1 "Gunicorn（页面不存在）")：使用Python语言编写的[WSGI](https://zh.wikipedia.org/wiki/WSGI "WSGI") [Web服务器](https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8 "Web服务器")。
- [Plone](https://zh.wikipedia.org/wiki/Plone "Plone")：基于[Zope](https://zh.wikipedia.org/wiki/Zope "Zope")的[内容管理系统](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F "内容管理系统")。
- [Mezzanine](https://zh.wikipedia.org/w/index.php?title=Mezzanine_\(CMS\)&action=edit&redlink=1 "Mezzanine (CMS)（页面不存在）")：基于[Django](https://zh.wikipedia.org/wiki/Django "Django")框架的[内容管理系统](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F "内容管理系统")。
- [Orange](https://zh.wikipedia.org/w/index.php?title=Orange_\(%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "Orange (软件)（页面不存在）")：基于[scikit-learn](https://zh.wikipedia.org/wiki/Scikit-learn "Scikit-learn")和[pandas](https://zh.wikipedia.org/wiki/Pandas "Pandas")的开源[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")和[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")软件，由[卢布尔雅那大学](https://zh.wikipedia.org/wiki/%E5%8D%A2%E5%B8%83%E5%B0%94%E9%9B%85%E9%82%A3%E5%A4%A7%E5%AD%A6 "卢布尔雅那大学")开发，利用了PyQt5和基于[Blink](https://zh.wikipedia.org/wiki/Blink "Blink")的PyQtWebEngine，通过广大多样的工具箱来建造[数据分析](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90 "数据分析")[工作流程](https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B "工作流程")[^295]。
- [SageMath](https://zh.wikipedia.org/wiki/SageMath "SageMath")：涵盖许多[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6 "数学")功能的应用软件，它建造在[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")、[SciPy](https://zh.wikipedia.org/wiki/SciPy "SciPy")、[matplotlib](https://zh.wikipedia.org/wiki/Matplotlib "Matplotlib")、[SymPy](https://zh.wikipedia.org/wiki/SymPy "SymPy")、[Maxima](https://zh.wikipedia.org/wiki/Maxima "Maxima")、[GAP](https://zh.wikipedia.org/w/index.php?title=GAP_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F\)&action=edit&redlink=1 "GAP (计算机代数系统)（页面不存在）")、[FLINT](https://zh.wikipedia.org/wiki/FLINT "FLINT")、[R](https://zh.wikipedia.org/wiki/R%E8%AF%AD%E8%A8%80 "R语言")等开源软件包之上。
- [Veusz](https://zh.wikipedia.org/w/index.php?title=Veusz&action=edit&redlink=1 "Veusz（页面不存在）")：用Python、[PyQt](https://zh.wikipedia.org/wiki/PyQt "PyQt")和[NumPy](https://zh.wikipedia.org/wiki/NumPy "NumPy")写成的科学绘图软件，可生成出版水准的[PDF](https://zh.wikipedia.org/wiki/PDF "PDF")或[SVG](https://zh.wikipedia.org/wiki/SVG "SVG")输出。
- [MayaVi](https://zh.wikipedia.org/w/index.php?title=MayaVi&action=edit&redlink=1 "MayaVi（页面不存在）")：基于[VTK](https://zh.wikipedia.org/wiki/VTK "VTK")的应用程序和库，用于交互式科学[数据可视化](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96 "数据可视化")和采用Python的3D绘图[^296]。
- [Blender](https://zh.wikipedia.org/wiki/Blender "Blender")：开源3D绘图软件，使用Python作为建模工具与GUI语言。
- [Inkscape](https://zh.wikipedia.org/wiki/Inkscape "Inkscape")：开源的[SVG](https://zh.wikipedia.org/wiki/SVG "SVG")矢量图形编辑器，使用Python用于插件。
- [Pitivi](https://zh.wikipedia.org/wiki/Pitivi "Pitivi")：用Python开发的基于[GStreamer](https://zh.wikipedia.org/wiki/GStreamer "GStreamer")的[视频编辑软件](https://zh.wikipedia.org/wiki/%E5%BD%B1%E7%89%87%E5%89%AA%E8%BC%AF%E8%BB%9F%E9%AB%94 "影片剪辑软件")。

经由Python开发了众多的[人工智能](https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD "人工智能")模型和作为其支撑的软件库：

- Ray：对[人工智能](https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD "人工智能")及Python应用的运行规模进行伸缩的统一框架[^297]，由Anyscale公司开发。它构成自一个核心的[分布式](https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97 "分布式计算")运行时系统，和加速[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")工作负载的AI软件库。
- Kornia：基于[PyTorch](https://zh.wikipedia.org/wiki/PyTorch "PyTorch")的[可微分](https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%BE%AE%E5%88%86%E7%BC%96%E7%A8%8B "可微分编程")[计算机视觉](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89 "计算机视觉")软件库[^298]。
- [spaCy](https://zh.wikipedia.org/w/index.php?title=SpaCy&action=edit&redlink=1 "SpaCy（页面不存在）")：用Python和Cython开发的工业级实力的[自然语言处理](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86 "自然语言处理")软件库[^299]。
- Argos Translate：基于OpenNMT的离线[神经机器翻译](https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91 "神经机器翻译")软件库[^300]。
- [Stable Diffusion](https://zh.wikipedia.org/wiki/Stable_Diffusion "Stable Diffusion")：用Python开发的[深度学习](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0 "深度学习")[文本到图像生成模型](https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E5%88%B0%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B "文本到图像生成模型")[^301]，基于了[CUDA](https://zh.wikipedia.org/wiki/CUDA "CUDA")、[PyTorch](https://zh.wikipedia.org/wiki/PyTorch "PyTorch")、[VAE](https://zh.wikipedia.org/wiki/%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8 "变分自编码器")、[U-Net](https://zh.wikipedia.org/wiki/U-Net "U-Net")和[OpenAI](https://zh.wikipedia.org/wiki/OpenAI "OpenAI")的CLIP[^302]，其代码和模型权重已公开发布，可以在大多数配备有适度[GPU](https://zh.wikipedia.org/wiki/GPU "GPU")的消费类计算机硬件上运行。
- [Transformers](https://zh.wikipedia.org/wiki/Hugging_Face#Transformers%E6%A8%A1%E5%9E%8B%E5%BA%93 "Hugging Face")：为下载和训练[前沿](https://zh.wikipedia.org/wiki/%E6%8A%80%E8%A1%93%E7%99%BC%E5%B1%95%E7%8F%BE%E7%8B%80 "技术发展现状")的预训练模型提供API和工具[^303]，由[Hugging Face](https://zh.wikipedia.org/wiki/Hugging_Face "Hugging Face")开发，支持在PyTorch、TensorFlow和JAX之间的框架互操作性。
- [Gradio](https://zh.wikipedia.org/wiki/Gradio "Gradio")：它是一个Python库，允许快速创建和分享用于机器学习模型、API或任何任意Python函数的Web应用程序。使用Gradio，可以构建交互式用户界面，与各种机器学习框架兼容。还可以使用Gradio以交互方式调试模型、从用户获取反馈，并通过自动生成的可共享链接轻松部署模型。[^304][^305]
- [LangChain](https://zh.wikipedia.org/wiki/LangChain "LangChain")：它是一个[应用框架](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6 "应用框架")，旨在简化使用[大型语言模型](https://zh.wikipedia.org/wiki/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B "大型语言模型")的应用程序。作为一个语言模型集成框架，LangChain的用例包括文档分析和总结摘要, 代码分析和[聊天机器人](https://zh.wikipedia.org/wiki/%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA "聊天机器人")。[^306] LangChain提供了一个标准接口，用于将不同的[语言模型](https://zh.wikipedia.org/wiki/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B "语言模型")（LLM）连接在一起，以及与其他工具和数据源的集成。

自从2003年，Python始终排行于[TIOBE编程社区索引](https://zh.wikipedia.org/w/index.php?title=TIOBE%E7%BC%96%E7%A8%8B%E7%A4%BE%E5%8C%BA%E7%B4%A2%E5%BC%95&action=edit&redlink=1 "TIOBE编程社区索引（页面不存在）")前十最流行编程语言，在2021年10月它首次达到了第一名最流行语言（居于[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言")和[Java](https://zh.wikipedia.org/wiki/Java "Java")之前）[^tiobe-index-307]，并被选为2007年、2010年、2018年、2020年和2021年的年度编程语言[^tiobe-index-307]。它有如下著名的社群：

- [PyCon](https://zh.wikipedia.org/wiki/PyCon "PyCon")：各地社群举办的会议，通常每年举办。各社群在会议中讨论Python相关的议题。
- Python Discord：参与者众多的Python社区[^308]。
- [PyLadies](https://zh.wikipedia.org/w/index.php?title=PyLadies&action=edit&redlink=1 "PyLadies（页面不存在）")：由女性社群发起的社群，主要注重于发展Python的女性程序设计社群。
- [Django Girls](https://zh.wikipedia.org/w/index.php?title=Django_Girls&action=edit&redlink=1 "Django Girls（页面不存在）")：使用[Django](https://zh.wikipedia.org/wiki/Django "Django")网页设计框架，推广使用Python进行网页设计的技术。

Python的设计和哲学已经影响了很多其他编程语言：

- [Boo](https://zh.wikipedia.org/wiki/Boo "Boo")：使用了缩进、类似的语法和类似的对象模型[^autont-90-309]。
- [Cobra](https://zh.wikipedia.org/w/index.php?title=Cobra%E8%AF%AD%E8%A8%80&action=edit&redlink=1 "Cobra语言（页面不存在）")：使用了缩进和类似的语法[^autont-91-310]。
- Coconut：在Python语法之上增加了用于[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B "函数式编程")的新特征的Python变体[^311]。
- [CoffeeScript](https://zh.wikipedia.org/wiki/CoffeeScript "CoffeeScript")：有受Python启发的语法。
- [ECMAScript](https://zh.wikipedia.org/wiki/ECMAScript "ECMAScript")/[JavaScript](https://zh.wikipedia.org/wiki/JavaScript "JavaScript")：从Python借鉴了[迭代器](https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8 "迭代器")和[生成器](https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8_\(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B\) "生成器 (计算机编程)")[^autont-93-312]。
- [GDScript](https://zh.wikipedia.org/wiki/Godot#GDScript "Godot")：内置于Godot游戏引擎的非常类似Python的脚本语言[^gdscript-23]。
- [Genie](https://zh.wikipedia.org/wiki/Genie_\(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80\) "Genie (编程语言)")：基于[Vala](https://zh.wikipedia.org/wiki/Vala "Vala")编译器的具有近似Python语法的语言。
- [Go](https://zh.wikipedia.org/wiki/Go "Go")：其设计原则受到了Python的[可读性](https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AF%BB%E6%80%A7 "可读性")与[易用性](https://zh.wikipedia.org/wiki/%E6%98%93%E7%94%A8%E6%80%A7 "易用性")的启发[^go-25]，享有相同风格的数组分片语法。
- [Groovy](https://zh.wikipedia.org/wiki/Groovy "Groovy")：受到Python等动态类型语言的影响[^autont-95-313]。
- [Julia](https://zh.wikipedia.org/wiki/Julia%E8%AF%AD%E8%A8%80 "Julia语言")：在表达高级数值计算的方式和支持通用编程上借鉴了Python等语言[^julia-28]。
- [Kotlin](https://zh.wikipedia.org/wiki/Kotlin "Kotlin")：融合了Python和Java特征，极小化了样板代码而增加了开发效率[^314]。
- [Mojo](https://zh.wikipedia.org/wiki/Mojo "Mojo")：基于[MLIR编译框架](https://zh.wikipedia.org/w/index.php?title=MLIR%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6&action=edit&redlink=1 "MLIR编译框架（页面不存在）")并设计为Python语言的[超集](https://zh.wikipedia.org/wiki/%E8%B6%85%E9%9B%86 "超集")[^%e2%80%9cmojo%e2%80%9d-315]。
- [Nim](https://zh.wikipedia.org/wiki/Nim "Nim")：使用缩进和类似的语法[^316]。
- [Ruby](https://zh.wikipedia.org/wiki/Ruby "Ruby")：主要从Python等语言中借鉴了特征[^bini-30]。
- [Starlark](https://zh.wikipedia.org/w/index.php?title=Bazel_\(%E8%BD%AF%E4%BB%B6\)&action=edit&redlink=1 "Bazel (软件)（页面不存在）")：用在Bazel软件中有受Python启发语法的语言[^starlark-31]。
- [Swift](https://zh.wikipedia.org/wiki/Swift%E8%AA%9E%E8%A8%80 "Swift语言")：有受Python启发的语法[^lattner2014-32]。

[^94]: 缩进示例：

```
def is_even(a: int) -> bool:
    """确定数a是否是偶数."""
    if a % 2 == 0:
        print('偶数!')
        return True
    print('奇数!')
    return False

# 参数比后续部份多一层缩进
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    # 可选的圆括号内后续行多一层缩进
    if (this_is_first_thing
            and that_is_second_thing):
        do_something()
    # 可选的圆括号内后续行不额外缩进
    elif (this_is_third_thing and
          that_is_fourth_thing):
        do_something_different()
# 参数相对行首缩进一层
spam = long_function_name(
    arg_one, arg_two,
    arg_three, arg_four)
# 参数按开括号界定垂直对齐
eggs = long_function_name(arg_one, arg_two,
                          arg_three, arg_four)
# 可选的闭括号位置
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
# 可选的闭括号位置
my_set = {
    1, 2, 3,
    4, 5, 6,
}
```

[^106]: 采用了并行赋值的[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97 "斐波那契数列")函数示例：

```
def fib(n):  # 写出从第0项到第n项的Fibonacci系列
    a, b, i = 0, 1, 0 
    while i <= n:
        print(a, end=' ')
        a, b, i = b, a+b, i+1
    print()
```

[^107]: 产生素数的惰性生成器的示例：

```
from itertools import count

def generate_primes(stop_at=0):
    if stop_at != 1:
        primes = [2]
        yield 2
    for n in count(3, 2):
        if 0 < stop_at < n:
            return # 引发StopIteration例外
        composite = False
        for p in primes:
            if not n % p:
                composite = True
                break
            elif p ** 2 > n:
                break
        if not composite:
            primes.append(n)
            yield n
```

上述函数的隐式迭代用例：

```
for i in generate_primes():  # 迭代于100以内所有素数上
    if i > 100:
        break
    print(i)
```

在生成器表达式中使用上述函数，定义了一个惰性的、巨大而并非无限的搜集的示例：

```
from itertools import islice

primes_under_million = (i for i in generate_primes() if i < 1000000)
two_thousandth_prime = islice(primes_under_million, 1999, 2000) 
print(next(two_thousandth_prime))
```

[^110]: 用生成器模拟协程示例：

```
def produce(n):
    try:
        for item in range(n):
            print(f'producing item {item} ->') 
            yield item
    except GeneratorExit:
        return

def consume():
    item = None
    try:
        while True:
            item = yield item
            print(f'consuming item {item} <-')
    except GeneratorExit:
        return

def main():
    r = []
    t1 = produce(10)
    t2 = consume()
    try:
        next(t2)
        while True:
            p = next(t1)
            r += [t2.send(p)]
    except StopIteration:
        t2.close()
    print(f'result items: {r}')

main()
```

[^118]: 遵循EAFP（请求原谅比获得许可更容易）风格的例外处理示例：

```
f = None
try:
    f = open("aFileName", mode="w")
    f.write(could_make_error()) # 不存在could_make_error()则产生错误
except IOError as error:
    print(error)
    print("不能打开文件")
except:  # 捕获所有例外
    print("未预期的错误")
else:  # 在没有出现例外时执行
    print("文件写入完全成功")
finally:  # 清除行动，总是执行
    if f:
        f.close()
```

[^121]: 使用`with`将文件作为资源来管理的示例：

```
from contextlib import contextmanager
@contextmanager
def opened(filename, mode="r"):
    try:
        f = open(filename, mode)
    except IOError as error:
        print(error)
        yield None
    else:
        try:
            yield f
        finally:
            f.close()

with opened("aFileName", mode="w") as f:
    try:
        f.write(could_make_error()) # 不存在could_make_error()则产生错误
    except AttributeError:
        print("不能打开文件")
    except:  # 捕获所有例外
        print("未预期的错误")
    else:  # 在没有出现例外时执行
        print("文件写入完全成功")
```

[^122]: 原生的协程示例：

```
import asyncio
import random

async def produce(queue, n):
    for item in range(n):
        # 生产一个项目，使用sleep模拟I/O操作
        print(f'producing item {item} ->') 
        await asyncio.sleep(random.random())
        # 将项目放入队列
        await queue.put(item)
    # 指示生产完毕
    await queue.put(None)

async def consume(queue):
    while True:
        # 等待来自生产者的项目
        item = await queue.get()
        if item is None:
            break
        # 消费这个项目，使用sleep模拟I/O操作
        print(f'consuming item {item} <-')
        await asyncio.sleep(random.random()) 

async def main():
    queue = asyncio.Queue()
    task1 = asyncio.create_task(produce(queue, 10))
    task2 = asyncio.create_task(consume(queue))
    await task1
    await task2

asyncio.run(main())
```

[^127]: 局部变量示例：

```
>>> def spam():
...     print(a)
... 
>>> a = 10
>>> spam()
10
>>> def spam():
...     a = 100
...     print(a)
... 
>>> spam()
100
>>> a
10
>>> def spam():
...     a *= 10
...     print(a)
... 
>>> spam()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in spam
UnboundLocalError: cannot access local variable 'a' where it is not associated with a value
```

[^128]: 全局变量示例：

```
>>> def spam():
...     global a
...     a *= 10
...     print(a)
... 
>>> a = 10
>>> spam()
100
>>> a
100
>>> def spam():
...     def eggs():
...         print(a)
...     global a
...     eggs()
... 
>>> a = 10
>>> spam()
10
>>> def spam():
...     def eggs():
...         a *= 10
...         print(a)
...     global a
...     eggs()
... 
>>> spam()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in spam
  File "<stdin>", line 3, in eggs
UnboundLocalError: cannot access local variable 'a' where it is not associated with a value
```

[^129]: 非局部变量示例：

```
>>> def spam():
...     def eggs():
...         nonlocal a
...         a *= 10
...         print(a)
...     a = 10
...     eggs()
... 
>>> spam()
100
>>> def spam():
...     def eggs():
...         nonlocal a
...         a *= 10
...         print(a)
...     global a
...     eggs()
... 
  File "<stdin>", line 3
SyntaxError: no binding for nonlocal 'a' found
```

[^135]: 序列解包、可迭代解包和字典解包示例：

```
>>> a = [1, 2, 3]; b = [4, 5]
>>> i, j, k = a
>>> print(i, j, k)
1 2 3
>>> c = [*a, b]
>>> c
[1, 2, 3, [4, 5]]
>>> d = {*a, *b}
>>> d
{1, 2, 3, 4, 5}
>>> e = (*a, *b)
>>> e
(1, 2, 3, 4, 5)
>>> f = {'as':1, 'bs':2 }; g = {'cs':3, 'ds':4}
>>> h = {**f, **g}
>>> h
{'as': 1, 'bs': 2, 'cs': 3, 'ds': 4}
```

[^136]: 列表的推导式示例。比如：

```
>>> [x + 3 for x in range(4)]
[3, 4, 5, 6]
```

[快速排序](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F "快速排序")算法可以优雅的（尽管不高效的）使用列表推导式表达为：

```
def qsort(L):
    if L == []:
        return []
    pivot = L[0]
    return (qsort([x for x in L[1:] if x < pivot]) +
            [pivot] +
            qsort([x for x in L[1:] if x >= pivot]))
```

[^138]: 生成器表达式示例。比如：

```
>>> sum(x * x for x in range(10))
285
>>> dict((n, n*n) for n in range(5))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
>>> set(n*n for n in range(5))
{0, 1, 4, 9, 16}
```

[^139]: 字典推导式`{expr1: expr2 for k, v in d}`，等价于：

```
result={}
for k, v in d.items():
    result[expr1]=expr2
return result
```

```
>>> {x: x + 3 for x in range(4)}
{0: 3, 1: 4, 2: 5, 3: 6}
```

集合推导式`{expr1 for x in stuff}`，等价于：

```
result = set()
for x in stuff:
    result.add(expr1)
return result
```

```
>>> {x + 3 for x in range(4)}
{3, 4, 5, 6}
```

[^141]: 下面几个判断语句为真，表示列表分片结果符合预期：

```
>>> nums = [1, 3, 5, 7, 8, 13, 20]
>>> nums[2:5] == [5, 7, 8] #从下标为2的元素切割到下标为5的元素，但不包含下标为5的元素。
True
>>> nums[1:] == [3, 5, 7, 8, 13, 20] #切割到最后一个元素。
True
>>> nums[:-3] == [1, 3, 5, 7] #从最开始的元素一直切割到倒数第3个元素。
True
>>> nums[:] == [1, 3, 5, 7, 8, 13, 20] #返回所有元素。改变新的列表不会影响到nums。
True
>>> nums[1:5:2] == [3, 7] #从下标为1的元素切割到下标为5的元素，但不包含下标为5的元素，且步长为2。
True
```

[^142]: 匿名函数示例：

```
>>> from functools import reduce
>>> reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) 
15
>>> fac = lambda n: (1 if n<2 else n*fac(n-1))
>>> fac(5)
120
>>> [*map(fac, [1, 2, 3, 4, 5])]
[1, 2, 6, 24, 120]
```

[不动点组合子](https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90 "不动点组合子")示例：

```
>>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))
>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))
>>> Y(fac)(5)
120
>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))
>>> Y(fib)(6)
8
>>> [*map((lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda n: (1 if n<2 else n*f(n-1))), [1, 2, 3, 4, 5])]
[1, 2, 6, 24, 120]
```

上述Y组合子代码源出自[Rosetta Code](https://rosettacode.org/wiki/Y_combinator#Python). \[2020-10-21\]. （原始内容[存档](https://web.archive.org/web/20210111053401/http://www.rosettacode.org/wiki/Y_combinator#Python)于2021-01-11）. 其原理可参见[Equational derivations of the Y combinator and Church encodings in Python](http://matt.might.net/articles/python-church-y-combinator/). \[2020-10-21\]. （原始内容[存档](https://web.archive.org/web/20201112034237/http://matt.might.net/articles/python-church-y-combinator/)于2020-11-12）.

[^147]: 多行字符串文字带有[字符串插值](https://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC&action=edit&redlink=1 "字符串插值（页面不存在）")（使用了`format`方法）的示例：

```
print("""亲爱的{recipient},

我希望你离开Sunnydale并永不返回.

不是很爱你的,
{sender}
""".format(sender="吸血鬼猎人Buffy", recipient="Spike"))
```

[^148]: 原始字符串的示例：

```
>>> # Windows路径，即使是原始字符串也不能结束于反斜杠
>>> r"C:\Spam\Eggs\Ham\"
  File "<stdin>", line 1
    r"C:\Spam\Eggs\Ham\"
                       ^
SyntaxError: EOL while scanning string literal
>>> dos_path = r"C:\Spam\Eggs\Ham\ " # 通过增加尾随的空格
>>> dos_path.rstrip()              # 并接着移除它来避免错误
'C:\\Spam\\Eggs\\Ham\\'
>>> quoted_dos_path = r'"{}"'.format(dos_path)
>>> quoted_dos_path
'"C:\\Spam\\Eggs\\Ham\\ "'
>>> # 匹配具有可能的反斜杠引述的引述字符串的正则表达式
>>> import re
>>> re.match(r'"(([^"\\]|\\.)*)"', quoted_dos_path).group(1).rstrip()
'C:\\Spam\\Eggs\\Ham\\'
>>> code = 'spam(2, eggs)'
>>> # 反转有二个参数的函数调用的两个实际参数
>>> re.sub(r'\(([^,]*),\s*([^,]*)\)', r'(\2, \1)', code)
'spam(eggs, 2)'
>>> # 注意如果实际参数中有圆括号或逗号则上例无效。
```

[^150]: 字符串文字符串接示例：

```
>>> print("hello " 'world')
hello world
>>> str1="hello "; str2='world'
>>> print(str1 + str2)
hello world
```

[^155]: 格式化字符串的示例，例如下列命令行`echo`命令：

```
num="3"; printer="HP Laserjet"
echo "I just printed ${num} pages to the printer ${printer}"
```

等价于如下Python中的任何一种`print`函数调用：

```
num = 3; printer="HP Laserjet"
print(f"I just printed {num} pages to the printer {printer}")

print("I just printed {} pages to the printer {}".format(num, printer))
print("I just printed {0} pages to the printer {1}".format(num, printer))
print("I just printed {num} pages to the printer {printer}".format(num=num, printer=printer))

print("I just printed %s pages to the printer %s" % (num, printer))
print("I just printed %(num)s pages to the printer %(printer)s" % {"num": num, "printer": printer})
```

[^156]: 词法闭包的例子：

```
def f(x):
    def g(y):
        return x + y
    return g  # 返回一个闭包。

h = lambda x: lambda y: x + y

# 将指定闭包赋值给变量。
a = f(1)
b = h(1)
c = f(2)
# 使用存储在变量中的闭包。
assert a(5) == 6
assert b(5) == 6
assert c(5) == 7
# 使用闭包而不事先把它们绑定到变量。
assert f(1)(5) == 6  # f(1)是个闭包。
assert h(1)(5) == 6  # h(1)是个闭包。
assert f(2)(5) == 7  # f(2)是个闭包。
```

[^159]: 函数的形式参数缺省值的持久性示例：

```
>>> def f(a, L=[]):
...     L.append(a)
...     return L
... 
>>> print(f(1))
[1]
>>> print(f(2))
[1, 2]
>>> print(f(3))
[1, 2, 3]
```

[^161]: 函数的形实参数二者结合示例。例如：

```
>>> def spam(a):
...     a.append('LovelySpam')
...     
>>> def eggs(b):
...     b=100 #实际上是重新绑定了另一个整型对象100
... 
>>> a=[]
>>> b=10
>>> spam(a)
>>> eggs(b)
>>> print(a)
['LovelySpam']
>>> print(b)
10
```

[^163]: 函数的形式参数缺省值的定义示例：

```
>>> from inspect import getfullargspec
>>> def func(p1, /, p2, p3="x", *, p4): pass
... 
>>> getfullargspec(func)
FullArgSpec(args=['p1', 'p2', 'p3'], varargs=None, varkw=None, defaults=('x',), kwonlyargs=['p4'], kwonlydefaults=None, annotations={})
```

[^164]: 函数的可变参数的定义示例：

```
>>> from inspect import getfullargspec
>>> def func(p1, /, p2, *args, p3, **kwargs): pass
... 
>>> getfullargspec(func)
FullArgSpec(args=['p1', 'p2'], varargs='args', varkw='kwargs', defaults=None, kwonlyargs=['p3'], kwonlydefaults=None, annotations={})
```

[^165]: 定义修饰器的示例：

```
def viking_chorus(myfunc):
    def inner_func(*args, **kwargs):
        for i in range(3):
            myfunc(*args, **kwargs)
    return inner_func
```

调用修饰器的示例：

```
@viking_chorus    
def menu_item(*args):
    print(", ".join(args)+", and spam")
```

等价于：

```
def menu_item(*args):
    print(", ".join(args)+", and spam")

menu_item = viking_chorus(menu_item)
```

`[viking](https://zh.wikipedia.org/wiki/%E7%B6%AD%E4%BA%AC%E4%BA%BA "維京人")_[chorus](https://zh.wikipedia.org/wiki/%E5%89%AF%E6%AD%8C "副歌")`修饰后的`menu_item`将原来定义运行3次：

```
>>> menu_item("egg","bacon")
egg, bacon, and spam
egg, bacon, and spam
egg, bacon, and spam
```

[^166]: 修饰器[工厂](https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95 "工厂方法")示例，这里的`favourite_colour`接受一个实际参数，并返回一个修饰器：

```
def favourite_colour(colour):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"My favourite colour is {colour}.")
            func(*args, **kwargs)
        return wrapper
    return decorator

def invincible(func):
    def wrapper(*args, **kwargs):
        print("I'm invincible!")
        func(*args, **kwargs)
    return wrapper
```

使用毗连的修饰符链接修饰器示例：

```
@invincible
@favourite_colour("blue")
def black_knight():
    print("None shall pass.")
```

使用中间变量链接修饰器示例：

```
blue_decorator = favourite_colour("blue")
decorated_by_blue = blue_decorator(black_knight)
black_knight = invincible(decorated_by_blue)
```

它们等价于：

```
black_knight = invincible(favourite_colour("blue")(black_knight))
```

[black\_knight](https://zh.wikipedia.org/w/index.php?title=%E9%BB%91%E9%AA%91%E5%A3%AB_\(%E5%B7%A8%E8%9F%92%E5%89%A7%E5%9B%A2\)&action=edit&redlink=1 "黑骑士 (巨蟒剧团)（页面不存在）")()结果为：

```
>>> black_knight()
I'm invincible!
My favourite colour is blue.
None shall pass.
```

[^169]: 调用函数使用帮助信息示例。比如：

```
>>> def randint(a, b):
...     "Return random integer in range [a, b], including both end points."
...
>>> help(randint)
Help on function randint in module __main__:   

randint(a, b)
    Return random integer in range [a, b], including both end points.
```

[^171]: 如下这样给参数增加类型标注的提示信息：

```
>>> def greeting(name: str) -> str:
...     return 'Hello ' + name
... 
>>> greeting.__annotations__
{'name': <class 'str'>, 'return': <class 'str'>}
```

[^177]: 对象的方法示例：

```
>>> class Fish(object):
...     hungry = True
...     def eat(self, food):
...         if food is not None:
...             self.hungry=False
... 
>>> def status(self):
...     print("Hungray!" if self.hungry else "Not hungray!")
... 
>>> e = Fish()
>>> status(e)
Hungray!
>>> Fish.hungry = False
>>> from types import MethodType
>>> e.status = MethodType(status, e)
>>> e.status()
Not hungray!
>>> Fish.hungry = True
>>> Fish.status = status
>>> f = Fish()
>>> Fish.status(f)
Hungray!
>>> f.eat("earthworm")
>>> f.status()
Not hungray!
```

[^179]: 特殊方法和子类调用超类方法的例子：

```
>>> class Thought(object):
...     cls_name = "类型Thought"
...     def __init_subclass__(cls):
...         cls.cls_name = "类型Thought的子类型"
...     def __init__(self, *args, **kwargs):
...         print(f"我是{type(self).cls_name}的新对象!")
...         if len(args) != 0 or len(kwargs) != 0:
...             print(f"init: nargs={len(args)}, nkwargs={len(kwargs)}")
...         self.notion = "我觉得我在平行宇宙中把车停歪了."
...     def message(self, *args):
...         print(self.notion)
...         if len(args) != 0:
...             print("\n".join(args))
... 
>>> class Advice(Thought):
...     def message(self):
...         super().message("警告: 日历里的日期比它们看起来更近!")
... 
>>> t = Thought()
我是类型Thought的新对象!
>>> t.message()
我觉得我在平行宇宙中把车停歪了.
>>> a = Advice()
我是类型Thought的子类型的新对象!
>>> a.message()
我觉得我在平行宇宙中把车停歪了.
警告: 日历里的日期比它们看起来更近!
>>> # 内省一下:
>>> [*super.__dict__]
['__new__', '__repr__', '__getattribute__', '__get__', '__init__', '__thisclass__', '__self__', '__self_class__', '__doc__']
>>> [*super(Advice).__thisclass__.__dict__]
['__module__', 'message', '__doc__', 'cls_name']
>>> super(Advice).__thisclass__.__dict__['cls_name']
'类型Thought的子类型'
>>> [*super(Advice, a).__self__.__dict__]
['notion']
>>> super(Advice, a).__self_class__.__dict__['cls_name']
'类型Thought的子类型'
>>> super(Advice, a).message()
我觉得我在平行宇宙中把车停歪了.
>>> super(Advice).__get__(a).message()
我觉得我在平行宇宙中把车停歪了.
```

[^181]: 在类中采用数据描述器的示例：

```
>>> class RevealAccess:
...     """正常的设置和返回值的数据描述器，
...        它还打印记录这次访问的一个消息。
...     """
...     def __init__(self, initval=None, name='var'):
...         self.val = initval
...         self.name = name
...     def __get__(self, obj, objtype):
...         print('Retrieving', self.name)
...         return self.val
...     def __set__(self, obj, val):
...         print('Updating', self.name)
...         self.val = val
... 
>>> class MyClass:
...     x = RevealAccess(10, 'var "x"')
...     y = 5
...
>>> m = MyClass()
>>> m.x
Retrieving var "x"
10
>>> vars(m)
{}
>>> MyClass.__dict__['x'].val
10
>>> m.x = 20
Updating var "x"
>>> vars(m)
{}
>>> MyClass.__dict__['x'].val
20
>>> m.y
5
>>> vars(m)
{}
>>> m.y = 5
>>> vars(m)
{'y': 5}
```

[^182]: 特殊方法、类方法和静态方法（`__new__()`）示例：

```
>>> from weakref import WeakValueDictionary
>>> class D:
...     _template = {}
...     _obj_dict = WeakValueDictionary()
...     def __new__(cls, *args, **kwargs):
...         obj = super(D, cls).__new__(cls)
...         cls._obj_dict[id(obj)] = obj
...         return obj
...     @classmethod
...     def load(cls, dict):
...         cls._template.update(dict)
...     @classmethod
...     def create(cls, *args, **kwargs):
...         return cls(cls._template, *args, **kwargs)
...     @classmethod
...     def count(cls):
...         return len(cls._obj_dict)
...     def __init__(self, dict={}, /, *args, **kwargs):
...         self.__dict__.update(dict)
...         self.__dict__.update(kwargs)
...     def __call__(self, *args, **kwargs):
...         self.__dict__.update(kwargs)
...         return self.__dict__.copy()
...     def __len__(self):
...         return len(self.__dict__)
...     def __getitem__(self, key):
...         return self.__dict__[key]
...     def __setitem__(self, key, value):
...         self.__dict__[key] = value
... 
>>> a = {'ak': 1, 'bk': 2, 'ck': 3}
>>> d = D(a, dk=4)
>>> d()
{'ak': 1, 'bk': 2, 'ck': 3, 'dk': 4}
>>> D.load(a)
>>> e = D.create(ck=4)
>>> e()
{'ak': 1, 'bk': 2, 'ck': 4}
>>> f = D(ak=1, bk=2)
>>> f(ck=3)
{'ak': 1, 'bk': 2, 'ck': 3}
>>> f['ak']
1
>>> f['ak'] = 5
>>> f()
{'ak': 5, 'bk': 2, 'ck': 3}
>>> len(f)
3
>>> D.count()
3
>>> del f
>>> D.count()
2
>>> d.__weakref__ in D._obj_dict.valuerefs()
True
```

[^184]: 在类中调用`property()`的例子：

```
>>> class C:
...     def __init__(self):
...         self.__x = None
...     def getx(self):
...         return self.__x
...     def setx(self, value):
...         self.__x = value
...     def delx(self):
...         del self.__x
...     x = property(getx, setx, delx, "I'm the 'x' property.")
... 
>>> c = C()
>>> vars(c)
{'_C__x': None}
>>> {*C.__dict__}
{'__init__', 'setx', '__weakref__', 'delx', 'x', 'getx', '__doc__', '__module__', '__dict__'}
```

上述代码可以采用修饰符进一步的书写为：

```
>>> class C:
...     def __init__(self):
...         self.__x = None
...     @property
...     def x(self):
...         """I'm the 'x' property."""
...         return self.__x
...     @x.setter
...     def x(self, value):
...         self.__x = value
...     @x.deleter
...     def x(self):
...         del self.__x
... 
>>> c = C()
>>> vars(c)
{'_C__x': None}
>>> {*C.__dict__}
{'__init__', '__weakref__', 'x', '__doc__', '__module__', '__dict__'}
```

[^186]: 建立列表的特殊语法示例：

```
a_list = [1, 2, 3, 'a dog']
```

采用正常的对象创建方式的示例：

```
a_second_list = list()
a_second_list.append(4)
a_second_list.append(5)
```

建立元组的特殊语法示例：

```
a_tuple = 1, 2, 3, 'four'
```

建立集合的特殊语法示例：

```
some_set = {0, (), False}
```

建立字典的特殊语法示例：

```
a_dictionary = {'key 1': 'value 1', 2: 3, 4: []}
```

[^187]: 两个类及元类等的实例关系（蓝色连接）与继承关系（绿色连接）示意图：

|  |  |  |
| --- | --- | --- |
| ``` r = object c = type class M(c): pass  class A(metaclass=M): pass  class B(A): pass  b = B() ``` |  | [![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Eigenclass-model-sample-pr.svg/169px-Eigenclass-model-sample-pr.svg.png)](https://zh.wikipedia.org/wiki/File:Eigenclass-model-sample-pr.svg) |

```
>>> type(b)
<class '__main__.B'>
>>> print(type(B), B.__bases__)
<class '__main__.M'> (<class '__main__.A'>,)
>>> print(type(A), A.__bases__)
<class '__main__.M'> (<class 'object'>,)
>>> print(type(M), M.__bases__)
<class 'type'> (<class 'type'>,)
>>> print(type(c), c.__bases__)
<class 'type'> (<class 'object'>,)
>>> print(type(r), r.__bases__)
<class 'type'> ()
```

[^204]: 数学运算示例。比如：

```
>>> def mean(seq):
...     return sum(seq) / len(seq)
... 
>>> mean([3, 4])
3.5
>>> import math
>>> print(math.sin(math.pi/2))
1.0
```

[^release-1]: [GitHub repository of Python 0.9.1 source](https://github.com/smontanaro/python-0.9.1). \[2023-02-25\]. （原始内容[存档](https://web.archive.org/web/20230305215559/https://github.com/smontanaro/python-0.9.1)于2023-03-05）.   
[HISTORY](https://raw.githubusercontent.com/python/cpython/master/Misc/HISTORY). Python source distribution. Python Foundation. \[2017-11-23\]. （原始内容[存档](https://web.archive.org/web/20171201033011/https://raw.githubusercontent.com/python/cpython/master/Misc/HISTORY)于2017-12-01）.

[^wikidata-b30fa7ab89fad1a0626747bd80b3d3350e7f3030-v3-2]: [Python 3.13.2 and 3.12.9 now available!](https://pythoninsider.blogspot.com/2025/02/python-3132-and-3129-now-available.html). 2025年2月4日 \[2025年2月5日\] （英语）.

[^wikidata-4ab371936a4164ef0fb368224406a306296afe3d-v3-3]: [Python 3.14.0 alpha 5 is out](https://pythoninsider.blogspot.com/2025/02/python-3140-alpha-5-is-out.html). 2025年2月11日 \[2025年2月12日\] （英语）.

[^wikidata-3a09e4fae0f28289a9642e468319d33991cce1a2-v3-4]: ["Python 3.14 Alpha 5 Released With New Tail-Call Interpreter"](https://www.phoronix.com/news/Python-3.14-Alpha-5); 检索日期: 2025年2月12日; 作品或名称使用语言: 英语; 出版日期: 2025年2月11日; 宣传物: Phoronix.

[^duck-5]: [Glossary — duck-typing](https://docs.python.org/3/glossary.html#term-duck-typing). \[2023-06-28\]. （原始内容[存档](https://web.archive.org/web/20200625153153/https://docs.python.org/3/glossary.html#term-duck-typing)于2020-06-25）.

[^6]: [Why is Python a dynamic language and also a strongly typed language - Python Wiki](https://web.archive.org/web/20210314173706/https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language). wiki.python.org. \[2021-01-27\]. （[原始内容](https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language)存档于2021-03-14）.

[^pep483-7]: [PEP 483 – The Theory of Type Hints](https://peps.python.org/pep-0483/). \[2023-03-16\]. （原始内容[存档](https://web.archive.org/web/20230326180923/https://peps.python.org/pep-0483/)于2023-03-26）.

[^8]: File extension .pyo was removed in Python 3.5. See [PEP 0488](https://www.python.org/dev/peps/pep-0488/) （[页面存档备份](https://web.archive.org/web/20200601133202/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）

[^9]: Holth, Moore. [PEP 0441 -- Improving Python ZIP Application Support](https://www.python.org/dev/peps/pep-0441/). 2014-03-30 \[2015-11-12\]. （原始内容[存档](https://web.archive.org/web/20181226141117/https://www.python.org/dev/peps/pep-0441/%20)于2018-12-26）.

[^faq-created-10]: [Why was Python created in the first place?](https://www.python.org/doc/faq/general/#why-was-python-created-in-the-first-place). Python FAQ. \[2007-03-22\]. （原始内容[存档](https://web.archive.org/web/20080223222507/http://www.python.org/doc/faq/general/#why-was-python-created-in-the-first-place)于2008-02-23）.

[^98-interview-11]: Andrew Kuchling, Guido van Rossum. [LJ Interviews Guido van Rossum](https://www.linuxjournal.com/article/2959). November 1, 1998 \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20230330151521/https://www.linuxjournal.com/article/2959)于2023-03-30）. String slicing came from Algol-68 and Icon.

[^func-12]: [The Python Standard Library － Functional Programming Modules － itertools — Functions creating iterators for efficient looping](https://web.archive.org/web/20200614153629/https://docs.python.org/3/library/itertools.html). \[2020-04-22\]. （[原始内容](https://docs.python.org/3/library/itertools.html)存档于2020-06-14）.

[^autont-1-13]: van Rossum, Guido. [An Introduction to Python for UNIX/C Programmers](https://web.archive.org/web/20130617064553/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.2023&rep=rep1&type=pdf). Proceedings of the NLUUG Najaarsconferentie (Dutch UNIX Users Group). 1993 \[2021-03-14\]. （[原始内容](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.2023&rep=rep1&type=pdf)存档于2013-06-17）. even though the design of C is far from ideal, its influence on Python is considerable.

[^classmix-14]: [The Python Tutorial － 9. Classes](https://web.archive.org/web/20121023030209/http://docs.python.org/tutorial/classes.html). \[20 February 2012\]. （[原始内容](https://docs.python.org/tutorial/classes.html)存档于2012-10-23）. Compared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3.

[^15]: Fredrik Lundh. [Python-list mailing list － passing by refference](https://mail.python.org/pipermail/python-list/2003-May/201671.html). \[2023-03-06\]. （原始内容[存档](https://web.archive.org/web/20230306210410/https://mail.python.org/pipermail/python-list/2003-May/201671.html)于2023-03-06）. replace "CLU" with "Python", "record" with "instance", and "procedure" with "function or method", and you get a pretty accurate description of Python's object model.

[^mro-16]: Simionato, Michele. [The Python 2.3 Method Resolution Order](https://web.archive.org/web/20200820231854/https://www.python.org/download/releases/2.3/mro/). Python Software Foundation. \[2021-03-14\]. （[原始内容](https://www.python.org/download/releases/2.3/mro/)存档于2020-08-20）. The C3 method itself has nothing to do with Python, since it was invented by people working on Dylan and it is described in a paper intended for lispers.

[^autont-3-17]: Kuchling, A. M. [Functional Programming HOWTO](https://web.archive.org/web/20121024163217/http://docs.python.org/howto/functional.html). Python v2.7.2 documentation. Python Software Foundation. \[9 February 2012\]. （[原始内容](https://docs.python.org/howto/functional.html)存档于2012-10-24）.

[^cwi_report-18]: Guido van Rossum. [Python Reference Manual － Version 1.2](https://ir.cwi.nl/pub/5008/05008D.pdf) (PDF). CWI Report CS-R9525. May 1995 \[2023-03-04\]. （原始内容[存档](https://web.archive.org/web/20230305215547/https://ir.cwi.nl/pub/5008/05008D.pdf) (PDF)于2023-03-05）. Python is a simple, yet powerful, interpreted programming language that bridges the gap between [C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言") and [shell](https://zh.wikipedia.org/wiki/Unix_shell "Unix shell") programming, and is thus ideally suited for "[throw-away](https://zh.wikipedia.org/w/index.php?title=%E8%BD%AF%E4%BB%B6%E5%8E%9F%E5%9E%8B&action=edit&redlink=1 "软件原型（页面不存在）") programming" and rapid prototyping. Its syntax is put together from constructs borrowed from a variety of other languages; most prominent are influences from [ABC](https://zh.wikipedia.org/wiki/ABC_\(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80\) "ABC (编程语言)"), [C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80 "C语言"), [Modula-3](https://zh.wikipedia.org/wiki/Modula-3 "Modula-3") and [Icon](https://zh.wikipedia.org/wiki/Icon%E8%AF%AD%E8%A8%80 "Icon语言").  
The Python interpreter is easily extended with new functions and data types implemented in C. Python is also suitable as an extension language for highly customizable C applications such as editors or window managers.

[^autont-5-19]: Smith, Kevin D.; Jewett, Jim J.; Montanaro, Skip; Baxter, Anthony. [PEP 318 – Decorators for Functions and Methods](https://web.archive.org/web/20200603133734/https://www.python.org/dev/peps/pep-0318/). Python Enhancement Proposals. Python Software Foundation. 2 September 2004 \[24 February 2012\]. （[原始内容](https://www.python.org/dev/peps/pep-0318/)存档于2020-06-03）.

[^autont-6-20]: [More Control Flow Tools](https://web.archive.org/web/20160604080843/https://docs.python.org/3.2/tutorial/controlflow.html). Python 3 documentation. Python Software Foundation. \[24 July 2015\]. （[原始内容](https://docs.python.org/3.2/tutorial/controlflow.html)存档于2016-06-04）.

[^21]: [re — Regular expression operations](https://docs.python.org/3/library/re.html). docs.python.org. \[2022-09-06\]. （原始内容[存档](https://web.archive.org/web/20180718132241/https://docs.python.org/3/library/re.html)于2018-07-18）. This module provides regular expression matching operations similar to those found in Perl.

[^22]: [CoffeeScript](https://web.archive.org/web/20200612100004/http://coffeescript.org/). coffeescript.org. \[2021-03-14\]. （[原始内容](https://coffeescript.org/)存档于2020-06-12）.

[^gdscript-23]: [FAQ: What is GDScript and why should I use it?](http://docs.godotengine.org/en/latest/about/faq.html#what-is-gdscript-and-why-should-i-use-it). \[2020-09-13\]. （原始内容[存档](https://web.archive.org/web/20200519082017/https://docs.godotengine.org/en/latest/about/faq.html#what-is-gdscript-and-why-should-i-use-it)于2020-05-19）.

[^24]: [The Genie Programming Language Tutorial](https://web.archive.org/web/20200601133216/https://wiki.gnome.org/action/show/Projects/Genie). \[28 February 2020\]. （[原始内容](https://wiki.gnome.org/action/show/Projects/Genie)存档于2020-06-01）.

[^go-25]: [Frequently Asked Questions (FAQ) - The Go Programming Language](https://golang.org/doc/faq#different_syntax). The Go Programming Language. \[February 26, 2016\]. （原始内容[存档](https://web.archive.org/web/20200503075008/https://golang.org/doc/faq#different_syntax)于2020-05-03）.

[^26]: [Perl and Python influences in JavaScript](https://web.archive.org/web/20181226141121/http://2ality.com/2013/02/javascript-influences.html%0A). www.2ality.com. 24 February 2013 \[15 May 2015\]. （[原始内容](http://www.2ality.com/2013/02/javascript-influences.html)存档于2018-12-26）.

[^27]: Rauschmayer, Axel. [Chapter 3: The Nature of JavaScript; Influences](https://web.archive.org/web/20181226141123/http://speakingjs.com/es5/ch03.html%0A). O'Reilly, Speaking JavaScript. \[15 May 2015\]. （[原始内容](http://speakingjs.com/es5/ch03.html)存档于2018-12-26）.

[^julia-28]: [Home · The Julia Language](https://docs.julialang.org/en/v1/). docs.julialang.org. \[2018-08-15\]. （原始内容[存档](https://web.archive.org/web/20210111031656/https://docs.julialang.org/en/v1/)于11 January 2021） （英语）.

[^mojo-29]: Krill, Paul. [Mojo language marries Python and MLIR for AI development](https://www.infoworld.com/article/3695588/mojo-language-marries-python-and-mlir-for-ai-development.html). InfoWorld. 2023-05-04 \[2023-05-05\]. （原始内容[存档](https://web.archive.org/web/20230505064554/https://www.infoworld.com/article/3695588/mojo-language-marries-python-and-mlir-for-ai-development.html)于5 May 2023） （英语）.

[^bini-30]: Bini, Ola. [Practical JRuby on Rails Web 2.0 Projects: Bringing Ruby on Rails to Java](https://archive.org/details/practicaljrubyon0000bini/page/3). Berkeley: APress. 2007: [3](https://archive.org/details/practicaljrubyon0000bini/page/3). [ISBN 978-1-59059-881-8](https://zh.wikipedia.org/wiki/Special:%E7%BD%91%E7%BB%9C%E4%B9%A6%E6%BA%90/978-1-59059-881-8 "Special:网络书源/978-1-59059-881-8"). It draws primarily on features from Perl, Smalltalk, Python, Lisp, Dylan, and CLU.

[^starlark-31]: [Starlark Language](https://web.archive.org/web/20200615140534/https://docs.bazel.build/versions/master/skylark/language.html). \[25 May 2019\]. （[原始内容](https://docs.bazel.build/versions/master/skylark/language.html)存档于2020-06-15）.

[^lattner2014-32]: Lattner, Chris. [Chris Lattner's Homepage](https://web.archive.org/web/20181225131628/http://nondot.org/sabre/). Chris Lattner. 3 June 2014 \[3 June 2014\]. （[原始内容](http://nondot.org/sabre/)存档于2018-12-25）. Of course, it also greatly benefited from the experiences hard-won by many other languages in the field, drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list.

[^33]: [彼德·诺米格](https://zh.wikipedia.org/wiki/%E5%BD%BC%E5%BE%B7%C2%B7%E8%AB%BE%E7%B1%B3%E6%A0%BC "彼德·诺米格"). [Python for Lisp Programmers](https://norvig.com/python-lisp.html). \[2020-04-21\]. （原始内容[存档](https://web.archive.org/web/20200614153604/https://norvig.com/python-lisp.html)于2020-06-14）. Python can be seen as a dialect of Lisp with "traditional" syntax (what Lisp people call "infix" or "m-lisp" syntax).

[^34]: Rossum, Guido Van. [The History of Python: A Brief Timeline of Python](https://python-history.blogspot.com/2009/01/brief-timeline-of-python.html). The History of Python. 2009-01-20 \[2021-03-05\]. （原始内容[存档](https://web.archive.org/web/20200605032200/https://python-history.blogspot.com/2009/01/brief-timeline-of-python.html)于5 June 2020）.

[^35]: Peterson, Benjamin. [Python Insider: Python 2.7.18, the last release of Python 2](https://pythoninsider.blogspot.com/2020/04/python-2718-last-release-of-python-2.html). Python Insider. 20 April 2020 \[27 April 2020\]. （原始内容[存档](https://web.archive.org/web/20200426204118/https://pythoninsider.blogspot.com/2020/04/python-2718-last-release-of-python-2.html)于26 April 2020）.

[^36]: [Stack Overflow Developer Survey 2020](https://insights.stackoverflow.com/survey/2020/). Stack Overflow. \[2021-03-05\]. （原始内容[存档](https://web.archive.org/web/20210302140729/https://insights.stackoverflow.com/survey/2020)于2 March 2021）.

[^37]: [The State of Developer Ecosystem in 2020 Infographic](https://www.jetbrains.com/lp/devecosystem-2020/). JetBrains: Developer Tools for Professionals and Teams. \[2021-03-05\]. （原始内容[存档](https://web.archive.org/web/20210301062411/https://www.jetbrains.com/lp/devecosystem-2020/)于1 March 2021） （英语）.

[^38]: [index | TIOBE - The Software Quality Company](https://www.tiobe.com/tiobe-index/). www.tiobe.com. \[2021-02-02\]. （原始内容[存档](https://web.archive.org/web/20180225101948/https://www.tiobe.com/tiobe-index/)于25 February 2018）. Python has won the TIOBE programming language of the year award! This is for the fourth time in the history, which is a record! The title is awarded to the programming language that has gained most popularity in one year.

[^39]: [PYPL PopularitY of Programming Language index](https://pypl.github.io/PYPL.html). pypl.github.io. \[2021-03-26\]. （原始内容[存档](https://web.archive.org/web/20170314232030/https://pypl.github.io/PYPL.html)于14 March 2017） （英语）.

[^40]: [Guido van Rossum - Resume](https://gvanrossum.github.io/Resume.html). \[2022-10-12\]. （原始内容[存档](https://web.archive.org/web/20221221201348/https://gvanrossum.github.io//Resume.html)于2022-12-21）.

[^41]: [amoeba operating system](https://github.com/OSPreservProject/amoeba/tree/master/thirdp). \[2023-02-25\]. （原始内容[存档](https://web.archive.org/web/20230305215547/https://github.com/OSPreservProject/amoeba/tree/master/thirdp)于2023-03-05）.

[^tutorial-chapter1-42]: [Whetting Your Appetite](https://docs.python.org/tutorial/appetite.html). The Python Tutorial. Python Software Foundation. \[2012-02-20\]. （原始内容[存档](https://web.archive.org/web/20121026063559/http://docs.python.org/tutorial/appetite.html)于2012-10-26）.

[^43]: [Benevolent dictator for life](https://web.archive.org/web/20061001143603/http://www.linuxformat.co.uk/modules.php?op=modload&name=Sections&file=index&req=viewarticle&artid=10). [Linux Format](https://zh.wikipedia.org/w/index.php?title=Linux_Format&action=edit&redlink=1 "Linux Format（页面不存在）"). 2005-02-01 \[2007-11-01\]. （[原始内容](http://www.linuxformat.co.uk/modules.php?op=modload&name=Sections&file=index&req=viewarticle&artid=10)存档于2006-10-01）.

[^44]: [Transfer of power](https://www.mail-archive.com/python-committers@python.org/msg05628.html). \[2020-11-29\]. （原始内容[存档](https://web.archive.org/web/20180712225051/https://www.mail-archive.com/python-committers@python.org/msg05628.html)于2018-07-12）.

[^45]: [PEP 8100](https://www.python.org/dev/peps/pep-8100/). python. Python Software Foundation. \[2019-05-04\]. （原始内容[存档](https://web.archive.org/web/20200604235027/https://www.python.org/dev/peps/pep-8100/)于2020-06-04）.

[^46]: [Steering Council nomination: Guido van Rossum (2020 term)](https://discuss.python.org/t/steering-council-nomination-guido-van-rossum-2020-term/2657/9). \[2020-10-11\]. （原始内容[存档](https://web.archive.org/web/20191229140536/https://discuss.python.org/t/steering-council-nomination-guido-van-rossum-2020-term/2657/9)于2019-12-29）.

[^venners-interview-pt-1-47]: [The Making of Python](http://www.artima.com/intv/pythonP.html). Artima Developer. \[2007-03-22\]. （原始内容[存档](https://web.archive.org/web/20160901183332/http://www.artima.com/intv/pythonP.html)于2016-09-01）.

[^48]: [Older source releases (1.0.1 - 1.6)](https://legacy.python.org/download/releases/src/). \[2023-03-05\]. （原始内容[存档](https://web.archive.org/web/20230305215547/https://legacy.python.org/download/releases/src/)于2023-03-05）.

[^49]: [HISTORY](https://raw.githubusercontent.com/python/cpython/master/Misc/HISTORY). \[2020-09-12\]. （原始内容[存档](https://web.archive.org/web/20171201033011/https://raw.githubusercontent.com/python/cpython/master/Misc/HISTORY)于2017-12-01）. Lambda expressions are particularly useful in combination with map(), filter() and reduce(), described below. Thanks to Amrit Prem for submitting this code (as well as map(), filter(), reduce() and xrange())!

[^50]: [LJ #37: Python 1.4 Update](https://web.archive.org/web/20070501080219/http://www.amk.ca/python/writing/12-14). \[2007-04-29\]. （[原始内容](http://www.amk.ca/python/writing/12-14)存档于2007-05-01）.

[^newin-2.0-51]: Kuchling, A. M.; Zadka, Moshe. [What's New in Python 2.0](https://docs.python.org/whatsnew/2.0.html). Python Software Foundation. 2000-10-16 \[2012-02-11\]. （原始内容[存档](https://web.archive.org/web/20121023112045/http://docs.python.org/whatsnew/2.0.html)于2012-10-23）.

[^pep-0227-52]: Hylton, Jeremy. [PEP 227 － Statically Nested Scopes](https://www.python.org/dev/peps/pep-0227/). 2000-11-01 \[2007-03-22\]. （原始内容[存档](https://web.archive.org/web/20070329062039/http://www.python.org/dev/peps/pep-0227/)于2007-03-29）.

[^unify-53]: Guido van Rossum. [Unifying types and classes in Python 2.2](https://www.python.org/download/releases/2.2.3/descrintro/). \[2020-09-26\]. （原始内容[存档](https://web.archive.org/web/20190928044604/https://www.python.org/download/releases/2.2.3/descrintro/)于2019-09-28）.

[^54]: [What’s New in Python 2.2 － PEP 234: Iterators](https://docs.python.org/3/whatsnew/2.2.html#pep-234-iterators). \[2020-10-21\]. （原始内容[存档](https://web.archive.org/web/20210207193626/https://docs.python.org/3/whatsnew/2.2.html#pep-234-iterators)于2021-02-07）.

[^pep-0255-55]: [What’s New in Python 2.2 － PEP 255: Simple Generators](https://web.archive.org/web/20210207193626/https://docs.python.org/3/whatsnew/2.2.html#pep-255-simple-generators). \[2020-10-21\]. （[原始内容](https://docs.python.org/3/whatsnew/2.2.html#pep-255-simple-generators)存档于2021-02-07）.

[^descriptor-56]: [What’s New in Python 2.2 － Descriptors](https://docs.python.org/3/whatsnew/2.2.html#descriptors). \[2020-10-21\]. （原始内容[存档](https://web.archive.org/web/20210207193626/https://docs.python.org/3/whatsnew/2.2.html#descriptors)于2021-02-07）.

[^decorator-57]: [What’s New in Python 2.4 － PEP 318: Decorators for Functions and Methods](https://docs.python.org/3/whatsnew/2.4.html#pep-318-decorators-for-functions-and-methods). \[2020-10-21\]. （原始内容[存档](https://web.archive.org/web/20210207193539/https://docs.python.org/3/whatsnew/2.4.html#pep-318-decorators-for-functions-and-methods)于2021-02-07）.

[^58]: [What’s New in Python 2.5 － PEP 343: The ‘with’ statement](https://docs.python.org/3/whatsnew/2.5.html#pep-343-the-with-statement). \[2020-10-21\]. （原始内容[存档](https://web.archive.org/web/20210207161900/https://docs.python.org/3/whatsnew/2.5.html#pep-343-the-with-statement)于2021-02-07）.

[^59]: [PEP 339 – Design of the CPython Compiler](https://peps.python.org/pep-0339/). 2005 \[2023-03-06\]. （原始内容[存档](https://web.archive.org/web/20230306025037/https://peps.python.org/pep-0339/)于2023-03-06）.

[^60]: Guido van Rossum. [What’s New In Python 3.0](https://docs.python.org/3/whatsnew/3.0.html). \[2023-02-18\]. （原始内容[存档](https://web.archive.org/web/20121102053959/https://docs.python.org/3/whatsnew/3.0.html)于2012-11-02）.

[^61]: [What’s New In Python 3.4 － asyncio](https://docs.python.org/3/whatsnew/3.4.html#whatsnew-asyncio). \[2023-02-22\]. （原始内容[存档](https://web.archive.org/web/20230613052927/https://docs.python.org/3/whatsnew/3.4.html#whatsnew-asyncio)于2023-06-13）.

[^62]: [What’s New In Python 3.5 － PEP 484 - Type Hints](https://docs.python.org/3/whatsnew/3.5.html#pep-484-type-hints). \[2023-02-25\]. （原始内容[存档](https://web.archive.org/web/20160618215313/https://docs.python.org/3//whatsnew/3.5.html#pep-484-type-hints)于2016-06-18）.

[^63]: [PEP 492 － Coroutines with async and await syntax](https://www.python.org/dev/peps/pep-0492/). \[2019-11-21\]. （原始内容[存档](https://web.archive.org/web/20190105061843/https://www.python.org/dev/peps/pep-0492/)于2019-01-05）.

[^assign-64]: [What’s New in Python 3.8 － Assignment expressions](https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions). \[2023-03-08\]. （原始内容[存档](https://web.archive.org/web/20210601101116/https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions)于2021-06-01）.

[^65]: Paul Krill, Guido Van Rossum. [Guido van Rossum resigns: What’s next for Python](https://www.infoworld.com/article/3292936/guido-van-rossum-resigns-whats-next-for-python.html). Jul 27, 2018 \[2023-03-19\]. （原始内容[存档](https://web.archive.org/web/20230319142852/https://www.infoworld.com/article/3292936/guido-van-rossum-resigns-whats-next-for-python.html)于2023-03-19）.

[^66]: [PEP 585 – Type Hinting Generics In Standard Collections](https://peps.python.org/pep-0585/). \[2023-03-17\]. （原始内容[存档](https://web.archive.org/web/20230525112331/https://peps.python.org/pep-0585/)于2023-05-25）.   
[The Python Standard Library － Built-in Types － Generic Alias Type](https://docs.python.org/3/library/stdtypes.html#generic-alias-type). \[2023-03-17\]. （原始内容[存档](https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#generic-alias-type)于2020-06-14）.

[^67]: [What’s New In Python 3.9 － New Parser](https://docs.python.org/3/whatsnew/3.9.html#new-parser). \[2023-02-22\]. （原始内容[存档](https://web.archive.org/web/20201007172936/https://docs.python.org/3/whatsnew/3.9.html#new-parser)于2020-10-07）.

[^68]: [What’s New In Python 3.10 － PEP 634: Structural Pattern Matching](https://docs.python.org/3/whatsnew/3.10.html#pep-634-structural-pattern-matching). \[2023-02-22\]. （原始内容[存档](https://web.archive.org/web/20230611130658/https://docs.python.org/3/whatsnew/3.10.html#pep-634-structural-pattern-matching)于2023-06-11）.

[^69]: [PEP 604 – Allow writing union types as X | Y](https://peps.python.org/pep-0604/). \[2023-03-17\]. （原始内容[存档](https://web.archive.org/web/20230526143138/https://peps.python.org/pep-0604/)于2023-05-26）.   
[The Python Standard Library － Built-in Types － Union Type](https://docs.python.org/3/library/stdtypes.html#union-type). \[2023-03-17\]. （原始内容[存档](https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#union-type)于2020-06-14）.

[^70]: [What’s New In Python 3.11 － Faster CPython](https://docs.python.org/3/whatsnew/3.11.html#faster-cpython). \[2023-03-24\]. （原始内容[存档](https://web.archive.org/web/20230613021748/https://docs.python.org/3/whatsnew/3.11.html#faster-cpython)于2023-06-13）.

[^71]: [What’s New In Python 3.12 — PEP 695: Type Parameter Syntax](https://docs.python.org/3/whatsnew/3.12.html#pep-695-type-parameter-syntax). \[2023-10-20\]. （原始内容[存档](https://web.archive.org/web/20231113053207/https://docs.python.org/3/whatsnew/3.12.html#pep-695-type-parameter-syntax)于2023-11-13）.

[^72]: [What’s New In Python 3.13](https://docs.python.org/3.13/whatsnew/3.13.html). \[2024-09-17\]. （原始内容[存档](https://web.archive.org/web/20240929015921/https://docs.python.org/3.13/whatsnew/3.13.html)于2024-09-29）.

[^73]: [Python Developer's Guide — Status of Python Version](https://devguide.python.org/versions/). devguide.python.org. \[2022-08-26\]. （原始内容[存档](https://web.archive.org/web/20220826132905/https://devguide.python.org/versions/)于2022-08-26）.

[^74]: [PEP 8106 – 2025 Term Steering Council election](https://peps.python.org/pep-8106/). Python Software Foundation. \[2024-12-11\]. （原始内容[存档](https://web.archive.org/web/20250130163622/https://peps.python.org/pep-8106/)于2025-01-30）.

[^special-method-names-75]: [The Python Language Reference － 3. Data model － Special method names](https://docs.python.org/3/reference/datamodel.html#special-method-names). \[2020-09-25\]. （原始内容[存档](https://web.archive.org/web/20121026063834/http://docs.python.org/reference/datamodel.html#special-method-names)于2012-10-26）.

[^76]: [aspectlib](https://web.archive.org/web/20141105061010/http://python-aspectlib.readthedocs.org/en/latest/). \[2020-09-28\]. （[原始内容](http://python-aspectlib.readthedocs.org/en/latest/)存档于2014-11-05）. aspectlib is an aspect-oriented programming, monkey-patch and decorators library. It is useful when changing behavior in existing code is desired.

[^autont-15~16-77]: [PEP 316 -- Programming by Contract for Python](https://www.python.org/dev/peps/pep-0316/). \[2021-01-17\]. （原始内容[存档](https://web.archive.org/web/20210122044926/https://www.python.org/dev/peps/pep-0316/)于2021-01-22）. 

- [Deal](https://web.archive.org/web/20210716090059/https://deal.readthedocs.io/). \[2021-06-20\]. （[原始内容](https://deal.readthedocs.io/)存档于2021-07-16）. python library for design by contract (DbC) and checking values, exceptions, and side-effects.
- [icontract](https://pypi.org/project/icontract/). \[2021-01-17\]. （原始内容[存档](https://web.archive.org/web/20210121042908/https://pypi.org/project/icontract/)于2021-01-21）. icontract provides design-by-contract to Python3 with informative violation messages and inheritance.
- [PyContracts](https://pypi.org/project/PyContracts/). \[2021-01-17\]. （原始内容[存档](https://web.archive.org/web/20210122045232/https://pypi.org/project/PyContracts/)于2021-01-22）. PyContracts is a Python package that allows to declare constraints on function parameters and return values.
- [dpcontracts](https://pypi.org/project/dpcontracts/). \[2021-01-17\]. （原始内容[存档](https://web.archive.org/web/20210122011715/https://pypi.org/project/dpcontracts/)于2021-01-22）. This module provides a collection of decorators that makes it easy to write software using contracts.

[^autont-17-78]: [PyDatalog](https://sites.google.com/site/pydatalog/). \[2012-07-22\]. （原始内容[存档](https://web.archive.org/web/20200613160231/https://sites.google.com/site/pydatalog/)于2020-06-13）.

[^reference_counting-79]: [Extending Python with C or C++ — Reference Counting in Python](https://docs.python.org/extending/extending.html#reference-counts). Docs.python.org. \[2020-06-05\]. （原始内容[存档](https://web.archive.org/web/20121018063230/http://docs.python.org/extending/extending.html#reference-counts)于2012-10-18） （英语）.

[^80]: [CPython’s internals — Garbage collector design — Optimization: generations](https://devguide.python.org/internals/garbage-collector/index.html#optimization-generations). \[2024-09-17\]. （原始内容[存档](https://web.archive.org/web/20250103022206/https://devguide.python.org/internals/garbage-collector/index.html#optimization-generations)于2025-01-03）.

[^81]: [Functional Programming HOWTO](https://docs.python.org/3/howto/functional.html). \[2020-09-26\]. （原始内容[存档](https://web.archive.org/web/20121024163217/http://docs.python.org/howto/functional.html)于2012-10-24）.

[^reduce-fate-82]: van Rossum, Guido. [The fate of reduce() in Python 3000](http://www.artima.com/weblogs/viewpost.jsp?thread=98196). Artima Developer. \[2007-03-22\]. （原始内容[存档](https://web.archive.org/web/20070407034617/http://www.artima.com/weblogs/viewpost.jsp?thread=98196)于2007-04-07）.

[^autont-18-83]: [Functional Programming Modules](https://docs.python.org/3/library/functional.html). Docs.python.org. \[2020-09-26\]. （原始内容[存档](https://web.archive.org/web/20200920200745/https://docs.python.org/3/library/functional.html)于2020-09-20）.

[^python_history-84]: Guido van Rossum. [Foreword for "Programming Python" (1st ed.)](https://www.python.org/doc/essays/foreword/). 1996-05-01 \[2020-09-12\]. （原始内容[存档](https://web.archive.org/web/20140724173913/https://www.python.org/doc/essays/foreword/)于2014-07-24）. Despite all its elegance and power and the availability of a free implementation, ABC never became popular in the Unix/C world. I can only speculate about the reasons, but here's a likely one: the difficulty of adding new "primitive" operations to ABC.

[^85]: Guido van Rossum. [Extending and Embedding the Python Interpreter － Version 1.2](https://ir.cwi.nl/pub/5006/5006D.pdf) (PDF). CWI Report CS-R9527. May 1995 \[2023-03-05\]. （原始内容[存档](https://web.archive.org/web/20230305215600/https://ir.cwi.nl/pub/5006/5006D.pdf) (PDF)于2023-03-05）. Python is an interpreted object oriented programming language. This document describes how to write modules in C or C++ to extend the Python interpreter with new modules. Those modules can define new functions but also new object types and their methods. The document also describes how to embed the Python interpreter in another application, for use as an extension language. Finally, it shows how to compile and link extension modules so that they can be loaded dynamically (at run time) into the interpreter, if the underlying operating system supports this feature.

[^86]: [The Python Standard Library － Generic Operating System Services － ctypes — A foreign function library for Python](https://web.archive.org/web/20220427182117/https://docs.python.org/3/library/ctypes.html). \[2022-01-14\]. （[原始内容](https://docs.python.org/3/library/ctypes.html)存档于2022-04-27）.

[^87]: [PEP 523 – Adding a frame evaluation API to CPython](https://peps.python.org/pep-0523/). \[2022-08-29\]. （原始内容[存档](https://web.archive.org/web/20220829133724/https://peps.python.org/pep-0523/)于2022-08-29）.

[^explicit-line-joining-88]: [The Python Language Reference － 2. Lexical analysis － Explicit line joining](https://docs.python.org/3/reference/lexical_analysis.html#explicit-line-joining). \[2023-02-17\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#explicit-line-joining)于2018-01-09）.

[^89]: [The Python Language Reference － 2. Lexical analysis － Comments](https://docs.python.org/3/reference/lexical_analysis.html#comments). \[2023-03-11\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#comments)于2018-01-09）.

[^90]: [The Python Language Reference － 7. Simple statements](https://docs.python.org/3/reference/simple_stmts.html). \[2020-10-30\]. （原始内容[存档](https://web.archive.org/web/20230606220648/https://docs.python.org/3/reference/simple_stmts.html)于2023-06-06）.   
[The Python Language Reference － 10. Full Grammar specification](https://docs.python.org/3/reference/grammar.html). \[2023-02-17\]. （原始内容[存档](https://web.archive.org/web/20230606220648/https://docs.python.org/3/reference/grammar.html)于2023-06-06）.  
`simple_stmts:`  
    `| simple_stmt !';' NEWLINE  # Not needed, there for speedup`  
    `| ';'.simple_stmt+ [';'] NEWLINE`

[^91]: [The Python Language Reference － 8. Compound statements](https://docs.python.org/3/reference/compound_stmts.html). \[2023-02-18\]. （原始内容[存档](https://web.archive.org/web/20191127123528/https://docs.python.org/3/reference/compound_stmts.html)于2019-11-27）.

[^92]: [The Python Language Reference － 10. Full Grammar specification](https://docs.python.org/3/reference/grammar.html). \[2023-02-17\]. （原始内容[存档](https://web.archive.org/web/20230606220648/https://docs.python.org/3/reference/grammar.html)于2023-06-06）.  
`statements: statement+`  
`statement: compound_stmt | simple_stmts`  
……  
`block:`  
    `| NEWLINE INDENT statements DEDENT`  
    `| simple_stmts`

[^93]: [PEP 8 – Style Guide for Python Code － Indentation](https://www.python.org/dev/peps/pep-0008/#indentation). \[2020-09-26\]. （原始内容[存档](https://web.archive.org/web/20180713002451/https://www.python.org/dev/peps/pep-0008/#indentation)于2018-07-13）.

[^95]: [The Python Language Reference － 2. Lexical analysis － Indentation](https://docs.python.org/3/reference/lexical_analysis.html#indentation). \[2023-02-18\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#indentation)于2018-01-09）.

[^96]: [The Python Language Reference － 2. Lexical analysis － Keywords](https://docs.python.org/3/reference/lexical_analysis.html#keywords). \[2020-09-26\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#keywords)于2018-01-09）.

[^97]: [What’s New In Python 3.0 － Overview Of Syntax Changes](https://docs.python.org/3/whatsnew/3.0.html#overview-of-syntax-changes). \[2023-02-18\]. （原始内容[存档](https://web.archive.org/web/20121102053959/https://docs.python.org/3/whatsnew/3.0.html#overview-of-syntax-changes)于2012-11-02）.

[^98]: [What’s What’s New In Python 3.5 － New Keywords](https://docs.python.org/3/whatsnew/3.5.html#new-keywords). \[2016-06-01\]. （原始内容[存档](https://web.archive.org/web/20160618215313/https://docs.python.org/3//whatsnew/3.5.html#new-keywords)于2016-06-18）.

[^99]: [What’s New In Python 3.7](https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights). \[2019-11-21\]. （原始内容[存档](https://web.archive.org/web/20191128153844/https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights)于2019-11-28）.

[^100]: [The Python Language Reference － 2. Lexical analysis － Soft Keywords](https://docs.python.org/3/reference/lexical_analysis.html#soft-keywords). \[2023-03-03\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#soft-keywords)于2018-01-09）.

[^101]: [PEP 8 – Style Guide for Python Code － Naming Conventions](https://www.python.org/dev/peps/pep-0008/#naming-conventions). \[2017-10-06\]. （原始内容[存档](https://web.archive.org/web/20180713002451/https://www.python.org/dev/peps/pep-0008/#naming-conventions)于2018-07-13）.

[^102]: [The Python Language Reference － 2. Lexical analysis － Reserved classes of identifiers](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers). \[2023-03-03\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers)于2018-01-09）.

[^private-var-103]: [9.6. Private Variables](https://docs.python.org/3/tutorial/classes.html#private-variables). \[2020-09-27\]. （原始内容[存档](https://web.archive.org/web/20121023030209/http://docs.python.org/tutorial/classes.html#private-variables)于2012-10-23）.

[^104]: [The Python Language Reference － 7. Simple statements － Augmented assignment statements](https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements). \[2023-03-08\]. （原始内容[存档](https://web.archive.org/web/20230606220648/https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements)于2023-06-06）.

[^105]: [The Python Tutorial － 5. Data Structures － Tuples and Sequences](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences). \[2018-10-17\]. （原始内容[存档](https://web.archive.org/web/20200610050047/https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences)于2020-06-10）.

[^108]: [The Python Language Reference － 6. Expressions － Yield expressions](https://docs.python.org/3/reference/expressions.html#yieldexpr). \[2023-03-15\]. （原始内容[存档](https://web.archive.org/web/20220907093916/https://docs.python.org/3/reference/expressions.html#yieldexpr)于2022-09-07）.

[^autont-57-109]: [PEP 342 － Coroutines via Enhanced Generators](https://www.python.org/dev/peps/pep-0342/). \[2019-11-21\]. （原始内容[存档](https://web.archive.org/web/20200529003739/https://www.python.org/dev/peps/pep-0342/)于2020-05-29）.

[^111]: [The Python Language Reference － 7. Simple statements － The yield statement](https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement). \[2023-03-15\]. （原始内容[存档](https://web.archive.org/web/20230606220648/https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement)于2023-06-06）.

[^autont-58-112]: [PEP 380 － Syntax for Delegating to a Subgenerator](https://www.python.org/dev/peps/pep-0380/). \[2019-11-21\]. （原始内容[存档](https://web.archive.org/web/20200604233821/https://www.python.org/dev/peps/pep-0380/)于2020-06-04）.

[^113]: [PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module － Coroutines](https://www.python.org/dev/peps/pep-3156/#coroutines). \[2019-11-21\]. （原始内容[存档](https://web.archive.org/web/20191114154241/https://www.python.org/dev/peps/pep-3156/#coroutines)于2019-11-14）.

[^114]: [Generator-based Coroutines](https://docs.python.org/3.10/library/asyncio-task.html#generator-based-coroutines). \[2020-10-29\]. （原始内容[存档](https://web.archive.org/web/20181231143720/https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines)于2018-12-31）. Support for generator-based coroutines is deprecated and is scheduled for removal in Python 3.10.

[^115]: [PEP 525 – Asynchronous Generators](https://peps.python.org/pep-0525/). \[2023-03-16\]. （原始内容[存档](https://web.archive.org/web/20230521064921/https://peps.python.org/pep-0525/)于2023-05-21）.

[^import-116]: [The Python Language Reference － 7. Simple statements － The import Statement](https://docs.python.org/3/reference/simple_stmts.html#import). \[2020-10-30\]. （原始内容[存档](https://web.archive.org/web/20210207193620/https://docs.python.org/3/reference/simple_stmts.html#import)于2021-02-07）.

[^modules-117]: [The Python Tutorial － 6. Modules](https://docs.python.org/3/tutorial/modules.html). \[2020-10-30\]. （原始内容[存档](https://web.archive.org/web/20210206205133/https://docs.python.org/3/tutorial/modules.html)于2021-02-06）.

[^119]: [What’s New In Python 3.11 － PEP 654: Exception Groups and except\*](https://docs.python.org/3/whatsnew/3.11.html#whatsnew311-pep654). \[2023-10-20\]. （原始内容[存档](https://web.archive.org/web/20230613021748/https://docs.python.org/3/whatsnew/3.11.html#whatsnew311-pep654)于2023-06-13）.

[^120]: [PEP 343 – The “with” Statement](https://www.python.org/dev/peps/pep-0343/). \[2020-09-26\]. （原始内容[存档](https://web.archive.org/web/20141214110002/https://www.python.org/dev/peps/pep-0343/)于2014-12-14）.

[^123]: [The Python Language Reference － 5. The import system － Packages](https://docs.python.org/3/reference/import.html#packages). \[2023-03-07\]. （原始内容[存档](https://web.archive.org/web/20220827204401/https://docs.python.org/3/reference/import.html#packages)于2022-08-27）.

[^124]: [The Python Standard Library － Python Runtime Services － \_\_main\_\_ — Top-level code environment](https://docs.python.org/3/library/__main__.html). \[2020-10-30\]. （原始内容[存档](https://web.archive.org/web/20210207193551/https://docs.python.org/3/library/__main__.html)于2021-02-07）.

[^naming&binding-125]: [The Python Language Reference － 4. Execution model － Naming and binding](https://docs.python.org/3/reference/executionmodel.html#naming-and-binding). \[2023-03-06\]. （原始内容[存档](https://web.archive.org/web/20220908064020/https://docs.python.org/3/reference/executionmodel.html#naming-and-binding)于2022-09-08）.

[^126]: [The Python Standard Library － Built-in Functions](https://docs.python.org/3/library/functions.html). \[2020-09-25\]. （原始内容[存档](https://web.archive.org/web/20121025141808/http://docs.python.org/py3k/library/functions.html)于2012-10-25）.

[^pep465-130]: [What’s New In Python 3.5 － PEP 465 － A dedicated infix operator for matrix multiplication](https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-465). \[2023-03-08\]. （原始内容[存档](https://web.archive.org/web/20160618215313/https://docs.python.org/3//whatsnew/3.5.html#whatsnew-pep-465)于2016-06-18）.

[^131]: [NumPy Reference － Routines － Linear algebra (numpy.linalg) － numpy.matmul](https://web.archive.org/web/20220410040855/https://numpy.org/doc/stable/reference/generated/numpy.matmul.html). \[2022-01-18\]. （[原始内容](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html)存档于2022-04-10）.

[^compare-132]: [The Python Language Reference － 6. Expressions － Comparison](https://docs.python.org/3/reference/expressions.html#comparisons). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20220907093916/https://docs.python.org/3/reference/expressions.html#comparisons)于2022-09-07）.

[^133]: [The Python Language Reference － 6. Expressions － Displays for lists, sets and dictionaries](https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries). \[2023-03-13\]. （原始内容[存档](https://web.archive.org/web/20220907093916/https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries)于2022-09-07）.

[^134]: [What’s New In Python 3.5 － PEP 448 － Additional Unpacking Generalizations](https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448). \[2023-03-08\]. （原始内容[存档](https://web.archive.org/web/20160618215313/https://docs.python.org/3//whatsnew/3.5.html#whatsnew-pep-448)于2016-06-18）.

[^autont-59-137]: Hettinger, Raymond. [PEP 289 – Generator Expressions](https://www.python.org/dev/peps/pep-0289/). Python Enhancement Proposals. Python Software Foundation. 2002-01-30 \[2012-02-19\]. （原始内容[存档](https://web.archive.org/web/20200614153717/https://www.python.org/dev/peps/pep-0289/)于2020-06-14）.

[^140]: [The Python Language Reference － 6. Expressions － Parenthesized forms](https://docs.python.org/3/reference/expressions.html#parenthesized-forms). \[2023-03-13\]. （原始内容[存档](https://web.archive.org/web/20220907093916/https://docs.python.org/3/reference/expressions.html#parenthesized-forms)于2022-09-07）.

[^143]: [The Python Language Reference － 6. Expressions － Assignment expressions](https://docs.python.org/3/reference/expressions.html#assignment-expressions). \[2023-03-08\]. （原始内容[存档](https://web.archive.org/web/20220907093916/https://docs.python.org/3/reference/expressions.html#assignment-expressions)于2022-09-07）.

[^144]: [The Python Language Reference － 6. Expressions － Operator precedence](https://docs.python.org/3/reference/expressions.html#operator-precedence). \[2023-03-12\]. （原始内容[存档](https://web.archive.org/web/20220907093916/https://docs.python.org/3/reference/expressions.html#operator-precedence)于2022-09-07）.

[^145]: [The Python Standard Library － Built-in Types － Common Sequence Operations](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations). \[2023-03-17\]. （原始内容[存档](https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)于2020-06-14）.

[^146]: [What’s New in Python 3.9 － Dictionary Merge & Update Operators](https://docs.python.org/3/whatsnew/3.9.html#dictionary-merge-update-operators). \[2021-06-12\]. （原始内容[存档](https://web.archive.org/web/20201007172936/https://docs.python.org/3/whatsnew/3.9.html#dictionary-merge-update-operators)于2020-10-07）.

[^149]: [The Python Language Reference － 2. Lexical analysis － String literal concatenation](https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation). \[2023-03-12\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation)于2018-01-09）.

[^151]: [The Python Standard Library － Built-in Types － printf-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)于2020-06-14）.

[^152]: [What’s New In Python 3.0 － PEP 3101: Advanced String Formatting](https://docs.python.org/3/whatsnew/3.0.html#pep-3101-a-new-approach-to-string-formatting). \[2023-03-19\]. （原始内容[存档](https://web.archive.org/web/20121102053959/https://docs.python.org/3/whatsnew/3.0.html#pep-3101-a-new-approach-to-string-formatting)于2012-11-02）.   
[The Python Standard Library － Text Processing Services － string — Common string operations － Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20230606213143/https://docs.python.org/3/library/string.html#format-string-syntax)于2023-06-06）.

[^153]: [The Python Language Reference － 2. Lexical analysis － Formatted string literals](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals). \[2023-03-13\]. （原始内容[存档](https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals)于2018-01-09）.

[^pep-0498-154]: [PEP 498 － Literal String Interpolation](https://www.python.org/dev/peps/pep-0498/). python.org. \[2017-03-08\]. （原始内容[存档](https://web.archive.org/web/20200615184141/https://www.python.org/dev/peps/pep-0498/)于2020-06-15）.

[^autont-55-157]: van Rossum, Guido. [Tail Recursion Elimination](http://neopythonic.blogspot.be/2009/04/tail-recursion-elimination.html). Neopythonic.blogspot.be. 2009-04-22 \[2012-12-03\]. （原始内容[存档](https://web.archive.org/web/20180519225253/http://neopythonic.blogspot.be/2009/04/tail-recursion-elimination.html)于2018-05-19）.   
van Rossum, Guido. [Language Design Is Not Just Solving Puzzles](http://www.artima.com/weblogs/viewpost.jsp?thread=147358). Artima forums. Artima. 2006-02-09 \[2007-03-21\]. （原始内容[存档](https://web.archive.org/web/20200117182525/https://www.artima.com/weblogs/viewpost.jsp?thread=147358)于2020-01-17）.

[^158]: [returns documentation — Trampolines](https://returns.readthedocs.io/en/latest/pages/trampolines.html). \[2024-09-28\]. （原始内容[存档](https://web.archive.org/web/20241223023325/https://returns.readthedocs.io/en/latest/pages/trampolines.html)于2024-12-23）.

[^160]: [The Python Tutorial － 4. More Control Flow Tools － Defining Functions](https://docs.python.org/3/tutorial/controlflow.html#id1). \[2023-03-06\]. （原始内容[存档](https://web.archive.org/web/20230610205356/https://docs.python.org/3/tutorial/controlflow.html#id1)于2023-06-10）.

[^162]: [Positional-only parameters](https://web.archive.org/web/20200608124345/https://docs.python.org/3.8/whatsnew/3.8.html#positional-only-parameters). \[2020-09-24\]. （[原始内容](https://docs.python.org/3.8/whatsnew/3.8.html#positional-only-parameters)存档于2020-06-08）.

[^167]: [Python 2.4 Decorators: Reducing code duplication and consolidating knowledge](http://www.ddj.com/184406073#l11). Dr. Dobb's. 2005-05-01 \[2007-02-08\]. （原始内容[存档](https://web.archive.org/web/20070206063944/http://www.ddj.com/184406073#l11)于2007-02-06）.

[^168]: [The Python Standard Library － Functional Programming Modules － functools — Higher-order functions and operations on callable objects](https://docs.python.org/3/library/functools.html). \[2023-03-18\]. （原始内容[存档](https://web.archive.org/web/20210602023813/https://docs.python.org/3/library/functools.html)于2021-06-02）.

[^170]: [PEP 3107 -- Function Annotations](https://web.archive.org/web/20150106050429/https://www.python.org/dev/peps/pep-3107/). \[2021-03-01\]. （[原始内容](https://www.python.org/dev/peps/pep-3107/)存档于2015-01-06）.

[^pep484-172]: [PEP 484 -- Type Hints](https://web.archive.org/web/20210209180311/https://www.python.org/dev/peps/pep-0484/). \[2021-03-01\]. （[原始内容](https://www.python.org/dev/peps/pep-0484/)存档于2021-02-09）.

[^autont-13-173]: [PEP 3115 – Metaclasses in Python 3000](https://peps.python.org/pep-3115/). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20230402003111/https://peps.python.org/pep-3115/)于2023-04-02）.

[^174]: [The Python Language Reference － 3. Data model － Customizing class creation](https://docs.python.org/3/reference/datamodel.html#customizing-class-creation). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20121026063834/https://docs.python.org/3/reference/datamodel.html#customizing-class-creation)于2012-10-26）.   
[PEP 487 – Simpler customisation of class creation](https://peps.python.org/pep-0487/). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20230321023214/https://peps.python.org/pep-0487/)于2023-03-21）.

[^175]: [The Python Standard Library － Built-in Types － Special Attributes](https://docs.python.org/3/library/stdtypes.html#special-attributes). \[2020-09-12\]. （原始内容[存档](https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#special-attributes)于2020-06-14）.

[^autont-61-176]: [Why must 'self' be used explicitly in method definitions and calls?](https://docs.python.org/faq/design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls). Design and History FAQ. Python Software Foundation. \[2012-02-19\]. （原始内容[存档](https://web.archive.org/web/20121024164243/http://docs.python.org/faq/design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls)于2012-10-24）.

[^super-178]: [The Python Standard Library － Built-in Functions － class super](https://docs.python.org/3/library/functions.html#super). \[2020-09-25\]. （原始内容[存档](https://web.archive.org/web/20181026035007/https://docs.python.org/3/library/functions.html#super)于2018-10-26）.

[^180]: [Descriptor HowTo Guide](https://docs.python.org/3/howto/descriptor.html). \[2020-09-26\]. （原始内容[存档](https://web.archive.org/web/20200918160150/https://docs.python.org/3/howto/descriptor.html)于2020-09-18）.

[^183]: [The Python Standard Library － Built-in Functions － class property](https://docs.python.org/3/library/functions.html#property). \[2020-09-25\]. （原始内容[存档](https://web.archive.org/web/20181026035007/https://docs.python.org/3/library/functions.html#property)于2018-10-26）.

[^185]: [The Python Language Reference － 3. Data model － The standard type hierarchy](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy).

[^classy-188]: [The Python Language Reference, section 3.3. New-style and classic classes, for release 2.7.18](https://docs.python.org/2.7/reference/datamodel.html#new-style-and-classic-classes). \[2020-09-25\]. （原始内容[存档](https://web.archive.org/web/20200505193709/https://docs.python.org/2.7/reference/datamodel.html#new-style-and-classic-classes)于2020-05-05）.

[^mypy-189]: [mypy - Optional Static Typing for Python](http://mypy-lang.org/). \[2017-01-28\]. （原始内容[存档](https://web.archive.org/web/20200606192012/http://mypy-lang.org/)于2020-06-06）.

[^pep0237-190]: Moshe Zadka, Guido van Rossum. [PEP 237 － Unifying Long Integers and Integers](https://www.python.org/dev/peps/pep-0237/). 2001-03-11. （原始内容[存档](https://web.archive.org/web/20200528063237/https://www.python.org/dev/peps/pep-0237/)于2020-05-28）.

[^191]: [The Python Tutorial － 15. Floating Point Arithmetic: Issues and Limitations](https://docs.python.org/3/tutorial/floatingpoint.html). \[2023-03-23\]. （原始内容[存档](https://web.archive.org/web/20230602024126/https://docs.python.org/3/tutorial/floatingpoint.html)于2023-06-02）. almost all platforms map Python floats to IEEE-754 “double precision”.

[^192]: [The Python Standard Library － Built-in Types － Ranges](https://docs.python.org/3/library/stdtypes.html#typesseq-range). \[2019-10-03\]. （原始内容[存档](https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#typesseq-range)于2020-06-14）.

[^193]: [NumPy fundamentals － Indexing on ndarrays － Dimensional indexing tools](https://numpy.org/doc/stable/user/basics.indexing.html#dimensional-indexing-tools). \[2023-03-23\]. （原始内容[存档](https://web.archive.org/web/20230601013722/https://numpy.org/doc/stable/user/basics.indexing.html#dimensional-indexing-tools)于2023-06-01）.

[^194]: [The Python Standard Library － Built-in Types － The Null Object](https://docs.python.org/3/library/stdtypes.html?highlight=null#the-null-object). \[2023-03-24\]. （原始内容[存档](https://web.archive.org/web/20230324024843/https://docs.python.org/3/library/stdtypes.html?highlight=null#the-null-object)于2023-03-24）.

[^pep0238-195]: Moshe Zadka, Guido van Rossum. [PEP 238 － Changing the Division Operator](https://www.python.org/dev/peps/pep-0238/). 2001-03-11 \[2013-10-23\]. （原始内容[存档](https://web.archive.org/web/20200528115550/https://www.python.org/dev/peps/pep-0238/)于2020-05-28）.

[^autont-62-196]: Guido van Rossum. [Why Python's Integer Division Floors](https://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html). 24 August 2010 \[25 August 2010\]. （原始内容[存档](https://web.archive.org/web/20200605151500/https://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html)于5 June 2020）.

[^197]: Guido van Rossum. [Python Reference Manual － Version 1.2](https://ir.cwi.nl/pub/5008/05008D.pdf) (PDF). CWI Report CS-R9525. May 1995 \[2023-03-04\]. （原始内容[存档](https://web.archive.org/web/20230305215547/https://ir.cwi.nl/pub/5008/05008D.pdf) (PDF)于2023-03-05）. The modulo operator always yields a result with the same sign as its second operand (or zero); …… The integer division and modulo operators are connected by the following identity: `x == (x/y)*y + (x%y)`.

[^autont-64-198]: [The Python Standard Library － Built-in Functions － round()](https://docs.python.org/3/library/functions.html#round), \[2023-03-21\], （原始内容[存档](https://web.archive.org/web/20121025141808/http://docs.python.org/py3k/library/functions.html#round)于2012-10-25）

[^199]: [Brian Kernighan](https://zh.wikipedia.org/wiki/Brian_Kernighan "Brian Kernighan"), [Dennis Ritchie](https://zh.wikipedia.org/wiki/Dennis_Ritchie "Dennis Ritchie"). [The C Programming Language, Second Edition](https://raw.githubusercontent.com/auspbro/ebook-c/master/The.C.Programming.Language.2Nd.Ed%20Prentice.Hall.Brian.W.Kernighan.and.Dennis.M.Ritchie..pdf) (PDF). Prentice Hall. 1988 \[2023-03-23\]. （原始内容[存档](https://web.archive.org/web/20230325110428/https://raw.githubusercontent.com/auspbro/ebook-c/master/The.C.Programming.Language.2Nd.Ed%20Prentice.Hall.Brian.W.Kernighan.and.Dennis.M.Ritchie..pdf) (PDF)于2023-03-25）. The relational operators group left-to-right, but this fact is not useful; `a<b<c` is parsed as `(a<b)<c`, and evaluates to either `0` or `1`.

[^200]: [PEP 327 – Decimal Data Type](https://www.python.org/dev/peps/pep-0327/). \[2015-09-26\]. （原始内容[存档](https://web.archive.org/web/20200604234830/https://www.python.org/dev/peps/pep-0327/)于2020-06-04）.

[^201]: [The Python Standard Library － Numeric and Mathematical Modules － decimal — Decimal fixed point and floating point arithmetic](https://docs.python.org/3/library/decimal.html). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20230613052928/https://docs.python.org/3/library/decimal.html)于2023-06-13）.

[^202]: [The Python Standard Library － Numeric and Mathematical Modules － fractions — Rational numbers](https://docs.python.org/3/library/fractions.html). \[2023-03-21\]. （原始内容[存档](https://web.archive.org/web/20230526170551/https://docs.python.org/3/library/fractions.html)于2023-05-26）.

[^203]: [gmpy2 is an optimized, C-coded Python extension module that supports fast multiple-precision arithmetic](https://github.com/aleaxit/gmpy). \[2024-10-14\]. （原始内容[存档](https://web.archive.org/web/20241219223924/https://github.com/aleaxit/gmpy)于2024-12-19）.

[^205]: [10 Reasons Python Rocks for Research (And a Few Reasons it Doesn't) – Hoyt Koepke](https://www.stat.washington.edu/~hoytak/blog/whypython.html). www.stat.washington.edu. \[2019-02-03\]. （原始内容[存档](https://web.archive.org/web/20200531211840/https://www.stat.washington.edu/~hoytak/blog/whypython.html)于2020-05-31）.

[^206]: Shell, Scott. [An introduction to Python for scientific computing](https://engineering.ucsb.edu/~shell/che210d/python.pdf) (PDF). 2014-06-17 \[2019-02-03\]. （原始内容[存档](https://web.archive.org/web/20190204014642/https://engineering.ucsb.edu/~shell/che210d/python.pdf) (PDF)于2019-02-04）.

[^207]: [The Python Standard Library](https://docs.python.org/3/library/index.html). \[2023-03-09\]. （原始内容[存档](https://web.archive.org/web/20230606041152/https://docs.python.org/3/library/index.html)于2023-06-06）.

[^208]: [Python Interpreters Benchmarks](https://pybenchmarks.org/). \[2022-08-30\]. （原始内容[存档](https://web.archive.org/web/20220820045505/https://pybenchmarks.org/)于2022-08-20）.

[^autont-67-209]: [Python Bytecode Instructions](https://docs.python.org/3/library/dis.html#python-bytecode-instructions). Docs.python.org. \[2016-02-16\]. （原始内容[存档](https://web.archive.org/web/20200605151542/https://docs.python.org/3/library/dis.html#python-bytecode-instructions)于2020-06-05）.   
[Python module to generate and modify bytecode](https://pypi.org/project/bytecode/). \[2023-02-22\]. （原始内容[存档](https://web.archive.org/web/20230404094427/https://pypi.org/project/bytecode/)于2023-04-04）.

[^210]: Obi Ike-Nwosu. [Inside The Python Virtual Machine](https://leanpub.com/insidethepythonvirtualmachine/read). \[2023-01-29\]. （原始内容[存档](https://web.archive.org/web/20210129122502/https://leanpub.com/insidethepythonvirtualmachine/read)于2021-01-29）.  [version 2019-03-02](https://yyrcd-1256568788.cos.na-siliconvalley.myqcloud.com/yyrcd/2019-12-10-insidethepythonvirtualmachine.pdf) (PDF). \[2023-01-30\]. （原始内容[存档](https://web.archive.org/web/20230305215653/https://yyrcd-1256568788.cos.na-siliconvalley.myqcloud.com/yyrcd/2019-12-10-insidethepythonvirtualmachine.pdf) (PDF)于2023-03-05）.  [中文翻译](https://nanguage.gitbook.io/inside-python-vm-cn/). \[2023-01-30\]. （原始内容[存档](https://web.archive.org/web/20230305215652/https://nanguage.gitbook.io/inside-python-vm-cn/)于2023-03-05）.

[^211]: [The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/python3-java.html). \[2023-01-31\]. （原始内容[存档](https://web.archive.org/web/20230522085924/https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/python3-java.html)于2023-05-22）.

[^212]: [Glossary — global interpreter lock](https://docs.python.org/3/glossary.html#term-global-interpreter-lock). \[2023-09-19\]. （原始内容[存档](https://web.archive.org/web/20200625153153/https://docs.python.org/3/glossary.html#term-global-interpreter-lock)于2020-06-25）.

[^213]: [Codon － A high-performance, zero-overhead, extensible Python compiler using LLVM](https://github.com/exaloop/codon). \[2023-03-24\]. （原始内容[存档](https://web.archive.org/web/20230525002419/https://github.com/exaloop/codon)于2023-05-25）.

[^214]: [Differences with Python](https://docs.exaloop.io/codon/general/differences). \[2024-09-26\]. （原始内容[存档](https://web.archive.org/web/20230525002540/https://docs.exaloop.io/codon/general/differences)于2023-05-25）.

[^215]: Rachel Gordon. [Python-based compiler achieves orders-of-magnitude speedups](https://www.csail.mit.edu/news/python-based-compiler-achieves-orders-magnitude-speedups). MIT CSAIL. March 14, 2023 \[2023-03-25\]. （原始内容[存档](https://web.archive.org/web/20230326161713/https://www.csail.mit.edu/news/python-based-compiler-achieves-orders-magnitude-speedups)于2023-03-26）.

[^216]: [Pyodide is a Python distribution for the browser and Node.js based on WebAssembly](https://github.com/pyodide/pyodide). \[2023-12-28\]. （原始内容[存档](https://web.archive.org/web/20240403030927/https://github.com/pyodide/pyodide)于2024-04-03）.

[^rustpython-217]: [RustPython](https://web.archive.org/web/20220424020708/https://rustpython.github.io/). \[2022-03-04\]. （[原始内容](https://rustpython.github.io/)存档于2022-04-24）.

[^218]: [Brython (Browser Python) is an implementation of Python 3 running in the browser](https://github.com/brython-dev/brython). \[2023-06-17\]. （原始内容[存档](https://web.archive.org/web/20231028074309/https://github.com/brython-dev/brython)于2023-10-28）.

[^219]: [Cython Users Guide — Using Parallelism](https://cython.readthedocs.io/en/latest/src/userguide/parallelism.html). \[2023-09-19\]. （原始内容[存档](https://web.archive.org/web/20231011015436/https://cython.readthedocs.io/en/latest/src/userguide/parallelism.html)于2023-10-11）.

[^220]: [mypyc — Compile type annotated Python to fast C extensions](https://github.com/mypyc/mypyc). \[2024-09-26\]. （原始内容[存档](https://web.archive.org/web/20250120232804/https://github.com/mypyc/mypyc)于2025-01-20）.

[^221]: [Pythran － Ahead of Time compiler for numeric kernels](https://github.com/serge-sans-paille/pythran). \[2022-08-29\]. （原始内容[存档](https://web.archive.org/web/20220829134536/https://github.com/serge-sans-paille/pythran)于2022-08-29）.

[^222]: [Nuitka is a Python compiler written in Python](https://github.com/Nuitka/Nuitka). \[2023-09-18\]. （原始内容[存档](https://web.archive.org/web/20231111153751/https://github.com/Nuitka/Nuitka)于2023-11-11）.

[^223]: [Transcrypt — Python 3.9 to JavaScript compiler - Lean, fast, open!](https://github.com/TranscryptOrg/transcrypt). \[2023-09-18\]. （原始内容[存档](https://web.archive.org/web/20230919030557/https://github.com/TranscryptOrg/transcrypt)于2023-09-19）.

[^224]: [MyHDL － From Python to Silicon!](https://www.myhdl.org/). \[2023-03-05\]. （原始内容[存档](https://web.archive.org/web/20230605234329/https://www.myhdl.org/)于2023-06-05）.

[^pyston-225]: [Pyston － A faster and highly-compatible implementation of the Python programming language](https://github.com/pyston/pyston). \[2022-08-29\]. （原始内容[存档](https://web.archive.org/web/20220829111025/https://github.com/pyston/pyston)于2022-08-29）. Pyston was started at Dropbox in 2014 ……. …… In 2017 …… Pyston project was shut down. …… In 2019 the Pyston developers regrouped ……. …… In mid-2021 the Pyston developers joined Anaconda …….

[^226]: [Pyjion － A JIT for Python based upon CoreCLR](https://github.com/tonybaloney/Pyjion). \[2022-08-29\]. （原始内容[存档](https://web.archive.org/web/20220829132400/https://github.com/tonybaloney/Pyjion)于2022-08-29）.

[^meta-227]: [Cinder is Meta's internal performance-oriented production version of CPython](https://github.com/facebookincubator/cinder). \[2022-08-26\]. （原始内容[存档](https://web.archive.org/web/20210504112500/https://github.com/facebookincubator/cinder)于2021-05-04）.

[^228]: [Tool recommendations](https://packaging.python.org/en/latest/guides/tool-recommendations/). python.org. \[21 April 2022\]. （原始内容[存档](https://web.archive.org/web/20220906214359/https://packaging.python.org/en/latest/guides/tool-recommendations/)于2022-09-06） （英语）.

[^229]: [venv — Creation of virtual environments](https://docs.python.org/3/library/venv.html). \[2023-05-07\]. （原始内容[存档](https://web.archive.org/web/20230613052929/https://docs.python.org/3/library/venv.html)于2023-06-13）.

[^230]: [virtualenv — A tool for creating isolated virtual python environments](https://github.com/pypa/virtualenv). \[2023-05-07\]. （原始内容[存档](https://web.archive.org/web/20230611174152/https://github.com/pypa/virtualenv)于2023-06-11）.

[^231]: [Pipenv — Python Development Workflow for Humans](https://github.com/pypa/pipenv). \[2022-08-29\]. （原始内容[存档](https://web.archive.org/web/20191117233244/https://github.com/pypa/pipenv)于2019-11-17）.

[^232]: [FAQ: Django appears to be a MVC framework, but you call the Controller the “view”, and the View the “template”. How come you don’t use the standard names?](https://docs.djangoproject.com/en/4.1/faq/general/#faq-mtv). \[2022-09-01\]. （原始内容[存档](https://web.archive.org/web/20220902170043/https://docs.djangoproject.com/en/4.1/faq/general/#faq-mtv)于2022-09-02）.

[^233]: [PyScript is an open source platform for Python in the browser](https://github.com/pyscript/pyscript). \[2024-09-26\]. （原始内容[存档](https://web.archive.org/web/20250118004951/https://github.com/pyscript/pyscript)于2025-01-18）.

[^234]: [uvloop is a fast, drop-in replacement of the built-in asyncio event loop](https://github.com/MagicStack/uvloop). \[2023-03-24\]. （原始内容[存档](https://web.archive.org/web/20230525214644/https://github.com/MagicStack/uvloop)于2023-05-25）.

[^235]: [Asynchronous HTTP Client/Server for asyncio and Python](https://docs.aiohttp.org/en/stable/). \[2021-01-14\]. （原始内容[存档](https://web.archive.org/web/20210115205648/https://docs.aiohttp.org/en/stable/)于2021-01-15）.

[^236]: [PyGObject is a Python package which provides bindings for GObject based libraries such as GTK, GStreamer, WebKitGTK, GLib, GIO and many more](https://pygobject.readthedocs.io/en/latest/). \[2023-03-05\]. （原始内容[存档](https://web.archive.org/web/20230607180612/https://pygobject.readthedocs.io/en/latest/)于2023-06-07）.

[^237]: [Remi － Python REMote Interface library](https://github.com/rawpython/remi). \[2022-08-28\]. （原始内容[存档](https://web.archive.org/web/20220828024606/https://github.com/rawpython/remi)于2022-08-28）.

[^238]: [PySimpleGUI － Python GUIs for Humans](https://github.com/PySimpleGUI/PySimpleGUI). \[2022-08-28\]. （原始内容[存档](https://web.archive.org/web/20220828023915/https://github.com/PySimpleGUI/PySimpleGUI)于2022-08-28）.

[^239]: [Gooey － Turn (almost) any Python command line program into a full GUI application with one line](https://github.com/chriskiehl/Gooey). \[2022-08-28\]. （原始内容[存档](https://web.archive.org/web/20220828023914/https://github.com/chriskiehl/Gooey)于2022-08-28）.

[^240]: [Dear PyGui: A fast and powerful Graphical User Interface Toolkit for Python with minimal dependencies](https://github.com/hoffstadt/DearPyGui). \[2023-03-18\]. （原始内容[存档](https://web.archive.org/web/20230518023800/https://github.com/hoffstadt/DearPyGui)于2023-05-18）.

[^241]: [pywebview is a lightweight cross-platform wrapper around a webview component that allows to display HTML content in its own native GUI window](https://github.com/r0x0r/pywebview/). \[2023-03-18\]. （原始内容[存档](https://web.archive.org/web/20230506022950/https://github.com/r0x0r/pywebview)于2023-05-06）.

[^242]: [NumPy Fundamentals and usage — Broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html). \[2023-09-20\]. （原始内容[存档](https://web.archive.org/web/20220703082618/https://numpy.org/doc/stable/user/basics.broadcasting.html)于2022-07-03）. The term broadcasting describes how NumPy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes.

[^243]: [CuPy: NumPy & SciPy for GPU](https://github.com/cupy/cupy). \[2022-08-31\]. （原始内容[存档](https://web.archive.org/web/20220831130748/https://github.com/cupy/cupy)于2022-08-31）.

[^244]: [DataFrame](https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe). \[2022-09-01\]. （原始内容[存档](https://web.archive.org/web/20220901165207/https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe)于2022-09-01）. DataFrame is a 2-dimensional labeled data structure with columns of potentially different types. You can think of it like a spreadsheet or SQL table, or a dict of Series objects. It is generally the most commonly used pandas object.

[^245]: [Python tools for data visualization — High-level tools](https://pyviz.org/high-level/index.html). \[2023-09-19\]. （原始内容[存档](https://web.archive.org/web/20230928011633/https://pyviz.org/high-level/index.html)于2023-09-28）.

[^246]: [Dask － Parallel computing with task scheduling](https://github.com/dask/dask). \[2022-08-31\]. （原始内容[存档](https://web.archive.org/web/20220831130744/https://github.com/dask/dask)于2022-08-31）.

[^247]: [Python tools for data visualization](https://pyviz.org/). \[2022-09-21\]. （原始内容[存档](https://web.archive.org/web/20240504233315/https://pyviz.org/)于2024-05-04）.

[^248]: [VisPy － interactive scientific visualization in Python](https://github.com/vispy/vispy). \[2022-08-30\]. （原始内容[存档](https://web.archive.org/web/20220713173217/https://github.com/vispy/vispy)于2022-07-13）.

[^249]: [glumpy — Python+Numpy+OpenGL: fast, scalable and beautiful scientific visualization](https://github.com/glumpy/glumpy). \[2023-09-18\]. （原始内容[存档](https://web.archive.org/web/20230919032236/https://github.com/glumpy/glumpy)于2023-09-19）.

[^250]: [seaborn: statistical data visualization](https://seaborn.pydata.org/). \[2024-09-24\]. （原始内容[存档](https://web.archive.org/web/20201203023307/https://seaborn.pydata.org/)于2020-12-03）.

[^251]: [Vega-Altair: Declarative Visualization in Python](https://github.com/vega/altair). \[2024-09-25\]. （原始内容[存档](https://web.archive.org/web/20250202134727/https://github.com/vega/altair)于2025-02-02）.

[^252]: [Bokeh — Interactive Data Visualization in the browser, from Python](https://github.com/bokeh/bokeh). \[2023-09-19\]. （原始内容[存档](https://web.archive.org/web/20231012211745/https://github.com/bokeh/bokeh)于2023-10-12）.

[^253]: [plotly.py is an interactive, open-source, and browser-based graphing library for Python](https://github.com/plotly/plotly.py). \[2024-09-24\]. （原始内容[存档](https://web.archive.org/web/20250124123733/https://github.com/plotly/plotly.py)于2025-01-24）.

[^254]: [Dash － Analytical Web Apps for Python, R, Julia, and Jupyter](https://github.com/plotly/dash). \[2022-09-21\]. （原始内容[存档](https://web.archive.org/web/20221205130045/https://github.com/plotly/dash)于2022-12-05）.

[^255]: [Plotly.js － Open-source JavaScript charting library behind Plotly and Dash](https://github.com/plotly/plotly.js). \[2022-09-21\]. （原始内容[存档](https://web.archive.org/web/20221221004034/https://github.com/plotly/plotly.js)于2022-12-21）.

[^256]: [Panel － A high-level app and dashboarding solution for Python](https://github.com/holoviz/panel). \[2022-09-21\]. （原始内容[存档](https://web.archive.org/web/20230116170335/https://github.com/holoviz/panel)于2023-01-16）.

[^257]: [HoloViz — High-level tools to simplify visualization in Python](https://holoviz.org/). \[2023-09-19\]. （原始内容[存档](https://web.archive.org/web/20231011015435/https://holoviz.org/)于2023-10-11）.

[^258]: [Streamlit — The fastest way to build data apps in Python](https://github.com/streamlit/streamlit). \[2022-09-21\]. （原始内容[存档](https://web.archive.org/web/20230117183856/https://github.com/streamlit/streamlit)于2023-01-17）.

[^259]: [Voilà － Voilà turns Jupyter notebooks into standalone web applications](https://github.com/voila-dashboards/voila). \[2022-09-21\]. （原始内容[存档](https://web.archive.org/web/20221231073738/https://github.com/voila-dashboards/voila)于2022-12-31）.

[^260]: [Joblib: running Python functions as pipeline jobs](https://joblib.readthedocs.io/en/latest/). \[2022-09-19\]. （原始内容[存档](https://web.archive.org/web/20221207033017/https://joblib.readthedocs.io/en/latest/)于2022-12-07）.

[^261]: [Thread-pool Controls](https://github.com/joblib/threadpoolctl). \[2022-09-19\]. （原始内容[存档](https://web.archive.org/web/20221102060115/http://github.com/joblib/threadpoolctl)于2022-11-02）.

[^262]: [TensorFlow API Documentation － Module: tf](https://www.tensorflow.org/api_docs/python/tf). \[2022-08-31\]. （原始内容[存档](https://web.archive.org/web/20220905031826/https://www.tensorflow.org/api_docs/python/tf)于2022-09-05）.

[^263]: [TensorFlow API Documentation － Module: tf.keras](https://www.tensorflow.org/api_docs/python/tf/keras). \[2022-08-31\]. （原始内容[存档](https://web.archive.org/web/20200122112434/https://www.tensorflow.org/api_docs/python/tf/keras)于2020-01-22）.

[^264]: [JAX － Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more](https://github.com/google/jax). \[2022-08-28\]. （原始内容[存档](https://web.archive.org/web/20210205153716/https://github.com/google/jax)于2021-02-05）.

[^265]: [Autograd － Efficiently computes derivatives of numpy code](https://github.com/HIPS/autograd). \[2022-08-28\]. （原始内容[存档](https://web.archive.org/web/20220718131101/https://github.com/hips/autograd)于2022-07-18）.

[^266]: [XLA: Optimizing Compiler for Machine Learning](https://www.tensorflow.org/xla). \[2022-08-28\]. （原始内容[存档](https://web.archive.org/web/20220901124303/https://www.tensorflow.org/xla)于2022-09-01）.

[^267]: [PEG parser generator for Python](https://pypi.org/project/pegen/). \[2023-02-22\]. （原始内容[存档](https://web.archive.org/web/20230305215722/https://pypi.org/project/pegen/)于2023-03-05）.   
Pablo Galindo Salgado. [Guide to the Parser](https://devguide.python.org/internals/parser/). \[2023-02-22\]. （原始内容[存档](https://web.archive.org/web/20230524015755/https://devguide.python.org/internals/parser/)于2023-05-24）.   
Bryan Ford. [The Packrat Parsing and Parsing Expression Grammars Page](https://bford.info/packrat/). \[2023-04-18\]. （原始内容[存档](https://web.archive.org/web/20230602092227/https://bford.info/packrat/)于2023-06-02）.

[^268]: [PeachPy － Portable Efficient Assembly Code-generator in Higher-level Python](https://github.com/Maratyszcza/PeachPy). \[2023-04-04\]. （原始内容[存档](https://web.archive.org/web/20230404182146/https://github.com/Maratyszcza/PeachPy)于2023-04-04）.

[^269]: [llvmlite — A lightweight LLVM python binding for writing JIT compilers](https://github.com/numba/llvmlite). \[2024-09-21\]. （原始内容[存档](https://web.archive.org/web/20250206174914/https://github.com/numba/llvmlite)于2025-02-06）.

[^270]: [SimPy — Discrete event simulation for Python](https://simpy.readthedocs.io/en/latest/). \[2023-08-17\]. （原始内容[存档](https://web.archive.org/web/20161212005606/http://simpy.readthedocs.io/en/latest/)于2016-12-12）.

[^271]: [PyOpenGL is the most common cross platform Python binding to OpenGL and related APIs](http://pyopengl.sourceforge.net/). \[2022-01-07\]. （原始内容[存档](https://web.archive.org/web/20110615075139/http://pyopengl.sourceforge.net/)于2011-06-15）.

[^272]: [ModernGL － Modern OpenGL binding for python](https://web.archive.org/web/20220415045537/https://github.com/moderngl/moderngl). \[2022-01-07\]. （[原始内容](https://github.com/moderngl/moderngl)存档于2022-04-15）.

[^273]: [CUDA Python Manual](https://nvidia.github.io/cuda-python/index.html). \[2022-08-30\]. （原始内容[存档](https://web.archive.org/web/20220830120906/https://nvidia.github.io/cuda-python/index.html)于2022-08-30）.

[^274]: [PyCUDA gives you easy, Pythonic access to Nvidia’s CUDA parallel computation API](https://documen.tician.de/pycuda/). \[2022-05-29\]. （原始内容[存档](https://web.archive.org/web/20220628010705/https://documen.tician.de/pycuda/)于2022-06-28）.

[^275]: [PyOpenCL gives you easy, Pythonic access to the OpenCL parallel computation API](https://web.archive.org/web/20220308163333/https://documen.tician.de/pyopencl/). \[2021-07-29\]. （[原始内容](https://documen.tician.de/pyopencl/)存档于2022-03-08）.

[^276]: [PySPH — A framework for Smoothed Particle Hydrodynamics in Python](https://github.com/pypr/pysph). \[2023-12-26\]. （原始内容[存档](https://web.archive.org/web/20231226022053/https://github.com/pypr/pysph)于2023-12-26）.

[^277]: [Kompute: Blazing fast, mobile-enabled, asynchronous, and optimized for advanced GPU processing usecases](https://pypi.org/project/kp/). \[2025-01-22\]. （原始内容[存档](https://web.archive.org/web/20250124000617/https://pypi.org/project/kp/)于2025-01-24）.

[^278]: [Taichi — Productive, portable, and performant GPU programming in Python](https://github.com/taichi-dev/taichi). \[2025-01-23\]. （原始内容[存档](https://web.archive.org/web/20250109234611/https://github.com/taichi-dev/taichi)于2025-01-09）.

[^279]: [Graphene — GraphQL framework for Python](https://github.com/graphql-python/graphene). \[2023-12-20\]. （原始内容[存档](https://web.archive.org/web/20240428101440/https://github.com/graphql-python/graphene)于2024-04-28）.

[^280]: [GQL — A GraphQL client in Python](https://github.com/graphql-python/gql). \[2023-12-25\]. （原始内容[存档](https://web.archive.org/web/20240424205146/https://github.com/graphql-python/gql)于2024-04-24）.

[^281]: [Pillow: a modern fork of PIL](https://web.archive.org/web/20160427040442/http://pillow.readthedocs.org/en/latest/). \[December 8, 2013\]. （[原始内容](http://pillow.readthedocs.org/en/latest/)存档于2016-04-27）.

[^282]: [pypdf － A pure-python PDF library capable of splitting, merging, cropping, and transforming the pages of PDF files](https://github.com/py-pdf/pypdf). \[2023-02-24\]. （原始内容[存档](https://web.archive.org/web/20230410223138/https://github.com/py-pdf/pypdf)于2023-04-10）.

[^283]: [PyFilesystem2 — Python's Filesystem abstraction layer](https://github.com/PyFilesystem/pyfilesystem2). \[2023-10-10\]. （原始内容[存档](https://web.archive.org/web/20231013073331/https://github.com/PyFilesystem/pyfilesystem2)于2023-10-13）.

[^284]: [Fabric － Pythonic remote execution](http://fabfile.org/). \[2013-04-08\]. （原始内容[存档](https://web.archive.org/web/20140411140705/http://fabfile.org/)于2014-04-11）.

[^285]: [Prefect － The easiest way to coordinate your dataflow](https://github.com/PrefectHQ/prefect). \[2022-09-22\]. （原始内容[存档](https://web.archive.org/web/20230111221459/https://github.com/prefecthq/prefect/)于2023-01-11）.

[^286]: [SDL Language Bindings](https://web.archive.org/web/20190312130817/http://libsdl.org/languages.php). \[2022-02-16\]. （[原始内容](https://www.libsdl.org/languages.php)存档于2019-03-12）.

[^287]: [Arcade — Easy to use Python library for creating 2D arcade games](https://api.arcade.academy/en/latest/). \[2023-10-10\]. （原始内容[存档](https://web.archive.org/web/20231108044756/https://api.arcade.academy/en/latest/)于2023-11-08）.

[^288]: [Pymunk is a easy-to-use pythonic 2d physics library that can be used whenever you need 2d rigid body physics from Python](https://github.com/viblo/pymunk). \[2024-09-24\]. （原始内容[存档](https://web.archive.org/web/20241126214851/https://github.com/viblo/pymunk)于2024-11-26）.

[^289]: [Panda3D Manual](https://www.panda3d.org/manual/index.php/Main_Page). \[2022-09-04\]. （原始内容[存档](https://web.archive.org/web/20181229224106/http://www.panda3d.org/manual/index.php/Main_Page)于2018-12-29）.

[^290]: [pythonnet － Python.NET](https://github.com/pythonnet/pythonnet). \[2022-08-30\]. （原始内容[存档](https://web.archive.org/web/20220901131605/https://github.com/pythonnet/pythonnet)于2022-09-01）.

[^291]: [PyInstaller bundles a Python application and all its dependencies into a single package](https://web.archive.org/web/20210607150432/https://www.pyinstaller.org/). \[2021-03-13\]. （[原始内容](https://www.pyinstaller.org/)存档于2021-06-07）.

[^292]: [LSB — Runtime Languages — Python Interpreter](https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Languages/LSB-Languages/python.html). \[2023-06-16\]. （原始内容[存档](https://web.archive.org/web/20160501210420/http://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Languages/LSB-Languages/python.html)于2016-05-01）.

[^293]: [pipx — Install and Run Python Applications in Isolated Environmentspipenv](https://github.com/pypa/pipx). \[2023-05-07\]. （原始内容[存档](https://web.archive.org/web/20230605082020/https://github.com/pypa/pipx)于2023-06-05）.

[^294]: [XONSH is a Python-powered shell](https://xon.sh/). \[2022-08-28\]. （原始内容[存档](https://web.archive.org/web/20220903204437/https://xon.sh/)于2022-09-03）.

[^295]: [Data Mining Fruitful and Fun － Open source machine learning and data visualization. Build data analysis workflows visually, with a large, diverse toolbox.](https://orangedatamining.com/). \[2023-06-14\]. （原始内容[存档](https://web.archive.org/web/20230606075151/https://orangedatamining.com/)于2023-06-06）.

[^296]: [Mayavi: 3D scientific data visualization and plotting in Python](https://github.com/enthought/mayavi). \[2023-09-20\]. （原始内容[存档](https://web.archive.org/web/20231011015434/https://github.com/enthought/mayavi)于2023-10-11）.

[^297]: [Ray － Effortlessly scale your most complex workloads](https://www.ray.io/). \[2022-09-19\]. （原始内容[存档](https://web.archive.org/web/20221213195430/https://www.ray.io/)于2022-12-13）.

[^298]: [Kornia － Open Source Differentiable Computer Vision Library](https://github.com/kornia/kornia/). \[2022-09-22\]. （原始内容[存档](https://web.archive.org/web/20230110205404/https://github.com/kornia/kornia)于2023-01-10）.

[^299]: [spaCy: Industrial-strength NLP](https://github.com/explosion/spaCy). \[2023-09-22\]. （原始内容[存档](https://web.archive.org/web/20231011015435/https://github.com/explosion/spaCy)于2023-10-11）.

[^300]: [Argos Translate — Open-source offline translation library written in Python](https://github.com/argosopentech/argos-translate). \[2023-10-01\]. （原始内容[存档](https://web.archive.org/web/20231113000456/https://github.com/argosopentech/argos-translate)于2023-11-13）.

[^301]: [Generative Models by Stability AI](https://github.com/Stability-AI/generative-models). \[2023-10-14\]. （原始内容[存档](https://web.archive.org/web/20231111083710/https://github.com/Stability-AI/generative-models)于2023-11-11）.

[^302]: [CLIP (Contrastive Language-Image Pretraining), Predict the most relevant text snippet given an image](https://github.com/openai/CLIP). \[2023-10-18\]. （原始内容[存档](https://web.archive.org/web/20230905161315/https://github.com/openai/CLIP)于2023-09-05）.

[^303]: [Transformers — State-of-the-art Machine Learning for PyTorch, TensorFlow, and JAX](https://huggingface.co/docs/transformers/index). \[2023-10-19\]. （原始内容[存档](https://web.archive.org/web/20230927023923/https://huggingface.co/docs/transformers/index)于2023-09-27）.

[^304]: [Gradio: The New Frontier in Interactive Python Data Apps](https://medium.com/@HeCanThink/gradio-the-new-frontier-in-interactive-python-data-apps-64b5ce06628a). \[2023-12-22\]. （原始内容[存档](https://web.archive.org/web/20231222020108/https://medium.com/@HeCanThink/gradio-the-new-frontier-in-interactive-python-data-apps-64b5ce06628a)于2023-12-22）.

[^305]: Python library for easily interacting with trained machine learning models [https://pypi.org/project/gradio/](https://pypi.org/project/gradio/) （[页面存档备份](https://web.archive.org/web/20240329200155/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）

[^306]: Buniatyan, Davit. [Code Understanding Using LangChain](https://www.activeloop.ai/resources/lang-chain-gpt-4-for-code-understanding-twitter-algorithm/). Activeloop. 2023 \[2023-12-22\]. （原始内容[存档](https://web.archive.org/web/20231216231643/https://www.activeloop.ai/resources/lang-chain-gpt-4-for-code-understanding-twitter-algorithm/)于2023-12-16）.

[^tiobe-index-307]: [TIOBE Index](http://www.tiobe.com/tiobe-index/). TIOBE - The Software Quality Company. \[2021-10-06\]. （原始内容[存档](https://web.archive.org/web/20200614043624/https://www.tiobe.com/tiobe-index/)于2020-06-14）.

[^308]: [Python Discord is a large community focused around the Python programming language](https://pythondiscord.com/). \[2021-01-13\]. （原始内容[存档](https://web.archive.org/web/20210201213730/https://pythondiscord.com/)于2021-02-01）.

[^autont-90-309]: [Gotchas for Python Users](https://web.archive.org/web/20081211062108/http://boo.codehaus.org/Gotchas+for+Python+Users). boo.codehaus.org. Codehaus Foundation. \[2008-11-24\]. （[原始内容](http://boo.codehaus.org/Gotchas+for+Python+Users)存档于2008-12-11）.

[^autont-91-310]: Esterbrook, Charles. [Acknowledgements](http://cobra-language.com/docs/acknowledgements/). cobra-language.com. Cobra Language. \[2010-04-07\]. （原始内容[存档](https://web.archive.org/web/20080208141002/http://cobra-language.com/docs/acknowledgements/)于2008-02-08）.

[^311]: [Coconut — Simple, elegant, Pythonic functional programming](https://github.com/evhub/coconut). \[2024-09-27\]. （原始内容[存档](https://web.archive.org/web/20250120030129/https://github.com/evhub/coconut)于2025-01-20）.

[^autont-93-312]: [Proposals: iterators and generators \[ES4 Wiki\]](https://web.archive.org/web/20071020082650/http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators). wiki.ecmascript.org. \[2008-11-24\]. （[原始内容](http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators)存档于2007-10-20）.

[^autont-95-313]: Strachan, James. [Groovy – the birth of a new dynamic language for the Java platform](https://web.archive.org/web/20070405085722/http://radio.weblogs.com/0112098/2003/08/29.html). 2003-08-29 \[2007-06-11\]. （[原始内容](http://radio.weblogs.com/0112098/2003/08/29.html)存档于2007-04-05）.

[^314]: Jalan, Nishant Aanjaney. [Programming in Kotlin](https://medium.com/codex/programming-in-kotlin-934bdb3659cf). CodeX. 2022-11-10 \[2024-04-29\]. （原始内容[存档](https://web.archive.org/web/20241130193515/https://medium.com/codex/programming-in-kotlin-934bdb3659cf)于2024-11-30） （英语）.

[^“mojo”-315]: [The Mojo Programming Language](https://github.com/modularml/mojo). github.com. Modular. 2023 \[2023-09-26\]. （原始内容[存档](https://web.archive.org/web/20231025133324/http://github.com/modularml/mojo)于2023-10-25）. Mojo is still young, but it is designed to become a superset of Python over time.

[^316]: Yegulalp, Serdar. [Nim language draws from best of Python, Rust, Go, and Lisp](https://www.infoworld.com/article/3157745/application-development/nim-language-draws-from-best-of-python-rust-go-and-lisp.html). InfoWorld. 2017-01-16 \[2020-09-13\]. （原始内容[存档](https://web.archive.org/web/20181013211847/https://www.infoworld.com/article/3157745/application-development/nim-language-draws-from-best-of-python-rust-go-and-lisp.html)于2018-10-13）. Nim's syntax is strongly reminiscent of Python's, as it uses indented code blocks and some of the same syntax (such as the way if/elif/then/else blocks are constructed).

- John DeNero. [Composing Programs, a free online introduction to programming and computer science](https://composingprograms.com/). \[2020-10-09\]. （原始内容[存档](https://web.archive.org/web/20210128225757/https://composingprograms.com/)于2021-01-28）.
- Allen B. Downey. [Think Python: How to Think Like a Computer Scientist - 2e](https://greenteapress.com/wp/think-python-2e/). Green Tea Press. 2012 \[2023-01-29\]. [ISBN 978-1-491-93936-9](https://zh.wikipedia.org/wiki/Special:%E7%BD%91%E7%BB%9C%E4%B9%A6%E6%BA%90/978-1-491-93936-9 "Special:网络书源/978-1-491-93936-9"). （原始内容[存档](https://web.archive.org/web/20230604080224/https://greenteapress.com/wp/think-python-2e/)于2023-06-04）.
- Obi Ike-Nwosu. [Intermediate Python](https://leanpub.com/intermediatepython/read). \[2023-01-29\]. （原始内容[存档](https://web.archive.org/web/20230305215724/https://leanpub.com/intermediatepython/read)于2023-03-05）.
- Luciano Ramalho. [Fluent Python (2nd ed.)](https://sd.blackball.lv/books/18944-fluent-python-2022). O'Reilly Media. 2022 \[2023-01-30\]. [ISBN 978-1-4920-5632-4](https://zh.wikipedia.org/wiki/Special:%E7%BD%91%E7%BB%9C%E4%B9%A6%E6%BA%90/978-1-4920-5632-4 "Special:网络书源/978-1-4920-5632-4"). （原始内容[存档](https://web.archive.org/web/20230305215730/https://sd.blackball.lv/books/18944-fluent-python-2022)于2023-03-05）.

- [编程语言列表](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%97%E8%A1%A8 "编程语言列表")
- [Python语法及语义](https://zh.wikipedia.org/wiki/Python%E8%AA%9E%E6%B3%95%E5%8F%8A%E8%AA%9E%E7%BE%A9 "Python语法及语义")
- [Python的历史](https://zh.wikipedia.org/wiki/Python%E7%9A%84%E6%AD%B7%E5%8F%B2 "Python的历史")
- [Python软件列表](https://zh.wikipedia.org/w/index.php?title=Python%E8%BD%AF%E4%BB%B6%E5%88%97%E8%A1%A8&action=edit&redlink=1 "Python软件列表（页面不存在）")

- [官方网站](https://www.python.org/) [![在维基数据上编辑此内容](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png)](https://www.wikidata.org/wiki/Q28865#P856 "在维基数据上编辑此内容")
- [Awesome Python](https://github.com/vinta/awesome-python) （[页面存档备份](https://web.archive.org/web/20210205024420/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [Real Python Tutorials](https://realpython.com/) （[页面存档备份](https://web.archive.org/web/20210207194322/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [programingz － Learn Python Programming](https://www.programiz.com/python-programming) （[页面存档备份](https://web.archive.org/web/20210208142230/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [w3schools － Python Tutorial](https://www.w3schools.com/python/) （[页面存档备份](https://web.archive.org/web/20210204202552/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [ItsMyCode－ Learn Python Programming](https://itsmycode.com/category/python/) （[页面存档备份](https://web.archive.org/web/20211026192003/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [Codecary － Learn Python Programming](https://codecary.com/category/python/) （[页面存档备份](https://web.archive.org/web/20211026192003/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [dainikchorcha － Learn Python Programming](https://dainikchorcha.com/)（[页面存档备份](https://web.archive.org/web/20220306124159/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [Tutlane - Learn Python Online](https://www.tutlane.com/tutorial/python) （[页面存档备份](https://web.archive.org/web/20210616043552/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [Brmgha - Learn & Challenges Python Online](https://www.brmgha.com/) （[页面存档备份](https://web.archive.org/web/20210616043552/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）
- [AlmaBetter- Python Tutorial](https://www.almabetter.com/bytes/tutorials/python) （[页面存档备份](https://web.archive.org/web/20231026130136/https)，存于[互联网档案馆](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86 "互联网档案馆")）