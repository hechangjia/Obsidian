/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/typed-assert/build/index.js
var require_build = __commonJS({
  "node_modules/typed-assert/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.check = exports.isPromise = exports.isInstanceOf = exports.isOneOfType = exports.isOneOf = exports.isOptionOfType = exports.isArrayOfType = exports.isRecordOfType = exports.isArray = exports.isRecordWithKeys = exports.isRecord = exports.isDate = exports.isString = exports.isNumber = exports.isBoolean = exports.isExactly = exports.isNotVoid = exports.isNotUndefined = exports.isNotNull = exports.isNever = exports.isUnknown = exports.safeJsonParse = exports.setBaseAssert = exports.assert = exports.defaultAssert = void 0;
    var expectedToBe = (type) => `expected to be ${type}`;
    var defaultAssert = (condition, message) => {
      if (!condition) {
        throw new TypeError(message);
      }
    };
    exports.defaultAssert = defaultAssert;
    var baseAssert = exports.defaultAssert;
    var assert = (condition, message) => baseAssert(condition, message);
    exports.assert = assert;
    function setBaseAssert(assert2) {
      if (assert2) {
        baseAssert = assert2;
      }
    }
    exports.setBaseAssert = setBaseAssert;
    var safeJsonParse = (json) => JSON.parse(json);
    exports.safeJsonParse = safeJsonParse;
    function isUnknown(_input) {
      return true;
    }
    exports.isUnknown = isUnknown;
    function isNever(_input, message = expectedToBe("unreachable")) {
      throw new TypeError(message);
    }
    exports.isNever = isNever;
    function isNotNull2(input, message = expectedToBe("not null")) {
      (0, exports.assert)(input !== null, message);
    }
    exports.isNotNull = isNotNull2;
    function isNotUndefined(input, message = expectedToBe("not undefined")) {
      (0, exports.assert)(input !== void 0, message);
    }
    exports.isNotUndefined = isNotUndefined;
    function isNotVoid2(input, message = expectedToBe("neither null nor undefined")) {
      (0, exports.assert)(input !== null && input !== void 0, message);
    }
    exports.isNotVoid = isNotVoid2;
    function isExactly(input, value, message = expectedToBe(`exactly ${value}`)) {
      (0, exports.assert)(input === value, message);
    }
    exports.isExactly = isExactly;
    function isBoolean(input, message = expectedToBe("a boolean")) {
      (0, exports.assert)(typeof input === "boolean", message);
    }
    exports.isBoolean = isBoolean;
    function isNumber(input, message = expectedToBe("a number")) {
      (0, exports.assert)(typeof input === "number", message);
    }
    exports.isNumber = isNumber;
    function isString(input, message = expectedToBe("a string")) {
      (0, exports.assert)(typeof input === "string", message);
    }
    exports.isString = isString;
    function isDate(input, message = expectedToBe("a Date")) {
      (0, exports.assert)(input instanceof Date, message);
    }
    exports.isDate = isDate;
    function isRecord(input, message = expectedToBe("a record")) {
      (0, exports.assert)(typeof input === "object", message);
      isNotNull2(input, message);
      for (const key of Object.keys(input)) {
        isString(key, message);
      }
    }
    exports.isRecord = isRecord;
    function isRecordWithKeys(input, keys, message = expectedToBe(`a record with keys ${keys.join(", ")}`)) {
      isRecord(input, message);
      for (const key of keys) {
        isNotUndefined(input[key]);
      }
    }
    exports.isRecordWithKeys = isRecordWithKeys;
    function isArray(input, message = expectedToBe("an array")) {
      (0, exports.assert)(Array.isArray(input), message);
    }
    exports.isArray = isArray;
    function isRecordOfType(input, assertT, message = expectedToBe("a record of given type"), itemMessage = expectedToBe("of given type")) {
      isRecord(input, message);
      for (const item of Object.values(input)) {
        assertT(item, itemMessage);
      }
    }
    exports.isRecordOfType = isRecordOfType;
    function isArrayOfType(input, assertT, message = expectedToBe("an array of given type"), itemMessage = expectedToBe("of given type")) {
      isArray(input, message);
      for (const item of input) {
        assertT(item, itemMessage);
      }
    }
    exports.isArrayOfType = isArrayOfType;
    function isOptionOfType(input, assertT, message = expectedToBe("option of given type")) {
      if (input === void 0) {
        return;
      }
      assertT(input, message);
    }
    exports.isOptionOfType = isOptionOfType;
    function isOneOf(input, values, message = expectedToBe(`one of ${values.join(", ")}`)) {
      (0, exports.assert)(values.includes(input), message);
    }
    exports.isOneOf = isOneOf;
    function isOneOfType(input, assertT, message = expectedToBe(`one of type`), itemMessage) {
      for (const assert2 of assertT) {
        try {
          assert2(input, itemMessage);
          return;
        } catch (_) {
        }
      }
      throw new TypeError(message);
    }
    exports.isOneOfType = isOneOfType;
    function isInstanceOf2(input, constructor, message = expectedToBe("an instance of given constructor")) {
      (0, exports.assert)(input instanceof constructor, message);
    }
    exports.isInstanceOf = isInstanceOf2;
    function isPromise(input, message = expectedToBe("a promise")) {
      isInstanceOf2(input, Promise, message);
    }
    exports.isPromise = isPromise;
    function check(assertT) {
      return (input) => {
        try {
          assertT(input);
          return true;
        } catch (_) {
          return false;
        }
      };
    }
    exports.check = check;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PersistentLinksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_typed_assert = __toESM(require_build());

// src/patterns.ts
var HEADING = /^#+\s.+$/gm;
var BLOCK_ID = /\s+(\^[a-zA-Z0-9-]+)$/gm;
var NOT_LETTER_OR_NUMBER = /[^\p{Letter}\p{Number}]/gu;
var FILE_PATH_IN_LINK = /(\[\[).*(#)/;

// src/utils.ts
var obsidian = __toESM(require("obsidian"));
function getBlockIds(text) {
  return [...text.matchAll(BLOCK_ID)].map((match) => match[1]);
}
function getHeadings(text) {
  return [...text.matchAll(HEADING)].map((match) => match[0]);
}
function normalizeHeading(text) {
  return text.replaceAll(NOT_LETTER_OR_NUMBER, "");
}
function getNormalizedHeadingInLink(link) {
  const headingPart = link.split("#")[1];
  if (headingPart) {
    return normalizeHeading(headingPart);
  }
  return null;
}
function parseLinkText(linkText) {
  const { path, subpath } = obsidian.parseLinktext(linkText);
  return {
    path,
    subpath: stripSubpathToken(subpath)
  };
}
function stripSubpathToken(subpath) {
  return subpath.replace(/#\^?/, "");
}
function replaceFilePathInLink(link, newPath) {
  return link.replace(FILE_PATH_IN_LINK, `$1${newPath}$2`);
}
function filterLinksToItemsPresentInText(links, text) {
  const blockIdsInText = getBlockIds(text);
  const headingsInText = getHeadings(text);
  return Object.entries(links).map(([filePath, links2]) => ({
    filePath,
    links: links2.filter(
      ({ link: linkText }) => blockIdsInText.some((id) => linkText.includes(id)) || headingsInText.some(
        (heading) => getNormalizedHeadingInLink(linkText) === normalizeHeading(heading)
      )
    )
  })).filter(({ links: links2 }) => links2.length > 0);
}
function redirectLinksInTextToNewPaths(linksWithPaths, text) {
  return linksWithPaths.slice().sort((a, b) => compareLinkOffsets(a.link, b.link)).reverse().reduce(
    (updatedText, { newPath, link: { position, original } }) => {
      const start = position.start.offset;
      const end = position.end.offset;
      const updatedLink = replaceFilePathInLink(original, newPath);
      return updatedText.substring(0, start) + updatedLink + updatedText.substring(end);
    },
    text
  );
}
function createUpdateNotice(results) {
  const fileCount = results.length;
  const linkCount = results.flatMap((f) => f.links).length;
  return `Updated ${linkCount} links in ${fileCount} files`;
}
function createRepairNotice(fixed, broken) {
  let result = "";
  if (fixed > 0) {
    result += `Fixed ${fixed} links`;
  }
  if (broken > 0) {
    result += `
Could not fix ${broken} links`;
  }
  return result;
}
function compareLinkOffsets(left, right) {
  return left.position.start.offset - right.position.start.offset;
}
function isSubpathInMetadata(subpath, metadata) {
  if (!metadata) {
    return false;
  }
  const { blocks, headings } = metadata;
  return blocks && subpath in blocks || headings && isSubpathInHeadingCache(subpath, headings);
}
function isSubpathInHeadingCache(subpath, headingCache) {
  return headingCache.some(
    ({ heading }) => normalizeHeading(heading) === normalizeHeading(subpath)
  );
}

// src/main.ts
var PersistentLinksPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.isLinkPathBroken = ({
      path,
      subpath
    }) => {
      const toFile = this.getFileFromPathRelativeToActiveFile(path);
      if (toFile === null) {
        return true;
      }
      return !isSubpathInMetadata(
        subpath,
        this.app.metadataCache.getFileCache(toFile)
      );
    };
    this.handleEditorPaste = async (event) => {
      var _a;
      if (!this.sourceFile) {
        return;
      }
      const clipboardContents = (_a = event == null ? void 0 : event.clipboardData) == null ? void 0 : _a.getData("text");
      if (!clipboardContents) {
        return;
      }
      const backlinksToUpdate = filterLinksToItemsPresentInText(
        this.getBacklinksForSourceFile(),
        clipboardContents
      );
      if (backlinksToUpdate.length === 0) {
        return;
      }
      this.runAfterMetadataUpdateIn(this.getActiveFile(), async () => {
        await this.redirectLinksToActiveFile(backlinksToUpdate);
        new import_obsidian.Notice(createUpdateNotice(backlinksToUpdate));
      });
    };
  }
  async onload() {
    this.addCommand({
      id: "persistent-links:repair-links-in-file",
      name: "Repair links in file",
      editorCallback: (editor) => {
        this.repairLinksInFile(editor);
      }
    });
    const body = document.querySelector("body");
    (0, import_typed_assert.isNotNull)(body);
    this.registerDomEvent(body, "cut", () => {
      this.sourceFile = this.app.workspace.getActiveFile();
    });
    this.app.workspace.on("editor-paste", this.handleEditorPaste);
  }
  onunload() {
    this.app.workspace.off("editor-paste", this.handleEditorPaste);
  }
  repairLinksInFile(editor) {
    const activeFileCache = this.app.metadataCache.getFileCache(
      this.getActiveFile()
    );
    if (!activeFileCache) {
      new import_obsidian.Notice("Nothing to fix");
      return;
    }
    const { links = [], embeds = [] } = activeFileCache;
    const { fixable, broken } = this.findNewPathsForBrokenLinks([
      ...links,
      ...embeds
    ]);
    if (fixable.length > 0) {
      editor.setValue(
        redirectLinksInTextToNewPaths(fixable, editor.getValue())
      );
    }
    new import_obsidian.Notice(createRepairNotice(fixable.length, broken.length));
  }
  findNewPathsForBrokenLinks(links) {
    return links.map((link) => ({ link, ...parseLinkText(link.link) })).filter(({ subpath }) => subpath).filter(this.isLinkPathBroken).map(({ link, subpath }) => ({
      link,
      newPath: this.findFileWithSubpathInCache(subpath)
    })).reduce(
      (result, { link, newPath }) => {
        newPath ? result.fixable.push({ link, newPath }) : result.broken.push(link);
        return result;
      },
      { fixable: [], broken: [] }
    );
  }
  findFileWithSubpathInCache(subpath) {
    const found = Object.entries(this.app.metadataCache.fileCache).find(
      ([, { hash }]) => isSubpathInMetadata(subpath, this.app.metadataCache.metadataCache[hash])
    );
    if (!found) {
      return null;
    }
    const newPath = this.getFileFromPathRelativeToActiveFile(found[0]);
    (0, import_typed_assert.isNotNull)(
      newPath,
      "Metadata cache contained a path that has the required subpath but doesn't point to a file"
    );
    return this.app.metadataCache.fileToLinktext(
      newPath,
      this.getActiveFile().path
    );
  }
  getFileFromPathRelativeToActiveFile(path) {
    return this.app.metadataCache.getFirstLinkpathDest(
      path,
      this.getActiveFile().path
    );
  }
  getBacklinksForSourceFile() {
    (0, import_typed_assert.isNotVoid)(this.sourceFile);
    return this.app.metadataCache.getBacklinksForFile(this.sourceFile).data;
  }
  async redirectLinksToActiveFile(links) {
    return Promise.all(
      links.map(async ({ filePath, links: links2 }) => {
        const contents = await this.readFile(filePath);
        const activeFilePath = this.getPathToActiveFileFrom(filePath);
        const linksWithNewPath = links2.map((link) => ({
          link,
          newPath: activeFilePath
        }));
        const updatedContents = redirectLinksInTextToNewPaths(
          linksWithNewPath,
          contents
        );
        return this.updateFile(filePath, updatedContents);
      })
    );
  }
  runAfterMetadataUpdateIn(targetFile, action) {
    const callback = (file) => {
      if (file !== targetFile) {
        return;
      }
      try {
        action();
      } finally {
        this.app.metadataCache.off("changed", callback);
      }
    };
    this.app.metadataCache.on("changed", callback);
  }
  getFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    (0, import_typed_assert.isInstanceOf)(file, import_obsidian.TFile);
    return file;
  }
  async readFile(path) {
    return this.app.vault.read(this.getFile(path));
  }
  async updateFile(path, newContents) {
    return this.app.vault.modify(this.getFile(path), newContents);
  }
  getPathToActiveFileFrom(sourcePath) {
    return this.app.metadataCache.fileToLinktext(
      this.getActiveFile(),
      sourcePath
    );
  }
  getActiveFile() {
    const activeFile = this.app.workspace.getActiveFile();
    (0, import_typed_assert.isNotNull)(activeFile);
    return activeFile;
  }
};


/* nosourcemap */